---
title: Web 零碎知识点
author: ecstAsy
date: "2022-02-09"
---

#### **1. 闭包(概念，作用，场景)**

- 概念：闭包就是能够读取其他函数内部变量的函数。例如在 javascript 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
- 作用：

#### **2. 函数节流**

- 概念： 在指定的时间内只会执行一次。
- 原理： 函数节流就是通过闭包保存一个标识 **(canDo = true)**，在函数开始时候判断这个标识是否为 **true** ,如果是 **true** 的话就继续执行函数，否则就 **return** 出去。判断完这个标识后，立即把这个 标识改为 **false** ，然后把外部传入的函数执行包在 **setTimeout** 中，最后在 **setTimeout** 执行完毕后，再把标识改为 **true** ，表示可以执行下一次任务了，在 **setTimeout** 没有执行完的时候，标识一直为 **false** ，在函数开头的时候会被 **return** 出去
- 代码：

```js
function throttle(fn, interval = 300) {
  let canDo = true;
  return () => {
    if (!canDo) return;
    setTimeout(() => {
      fn.apply(this, arguments);
      canDo = true;
    }, interval);
  };
}
```

- 场景：搜索引擎

#### **3. 函数防抖**

- 概念：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。
- 原理：函数防抖就是通过闭包保存一个标记来保存 **setTimeout** 返回的值，每当用户输入的时候把前一个 **setTimeout clear** 掉，然后又创建一个新的 **setTimeout**，这样就能保证输入字符后的 **interval** 间隔内如果还有字符输入的话，就不会执行 fn 函数了。
- 代码：

```js
function debounce(fn, interval = 300) {
  let timeout = null;
  return function () {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    }, interval);
  };
}
```

- 场景： 表单提交，付款

#### **4. Promise setTimeOut**

- 首先 Promise 构造函数会立即执行，而 Promise.then()内部的代码在当次事件循环的结尾立即执行(微任务)。
- promise 的状态一旦由等待 pending 变为成功 fulfilled 或者失败 rejected。那么当前 promise 被标记为完成，后面则不会再次改变该状态。
- resolve 函数和 reject 函数都将当前 Promise 状态改为完成，并将异步结果，或者错误结果当做参数返回。

#### **5. package.json 中，版本号前面的^和～**

- `~`: 匹配最新补丁版本号，也就是版本号的第三个数字。比如~1.2.3 将匹配所有 1.2.x 版本，但将在 1.3.0 上停止。
- `^`: 比较宽松，它匹配的是最新次要版本号，也就是第二个数字。比如：^ 1.2.3 将匹配任何 1.x.x 版本，包括 1.3.0，但将在 2.0.0 上停止。
- `*`: 匹配任意版本，一般不用
- `latest`: 安装的永远是最新的版本

#### **6. 堆(heap)和栈(stack)有什么区别存储机制**

- **栈(stack)**：**是一种连续储存的数据结构，具有先进后出后进先出的性质。**<br/>
  通常的操作有入栈（压栈），出栈和栈顶元素。想要读取栈中的某个元素，就是将其之间的所有元素出栈才能完成。

- **堆(heap)**：**是一种非连续的树形储存数据结构，具有队列优先,先进先出。**<br/>
  每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。

#### **7. 什么是深拷贝，浅拷贝，浅拷贝 赋值的区别，如何实现**

:::tip
**深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。**
:::

- **浅拷贝**

  - 将原对象或原数组的引用直接赋给新对象，新数组，新对象只是对原对象的一个引用，而不复制对象本身，新旧对象还是共享同一块内存
  - 如果**属性是一个基本数据类型，拷贝就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址**
  - 浅拷贝的实现方式
    - `object.assign()`
    - `lodash` 里面的 `_.clone`
    - `...`扩展运算符
    - `Array.prototype.concat`
    - `Array.prototype.clice`

- **深拷贝**
  - 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”
  - **深拷贝就是把一个对象，从内存中完整的拷贝出来，从堆内存中开辟了新区域，用来存新对象，并且修改新对象不会影响原对象**
  - 深拷贝的实现方式
    - `JSON.parse(JSON.stringify())`
    - **递归操作**
    - `cloneDeep`
    - `Jquery.extend()`
- **赋值**
  - 当我们把一个**对象赋值给一个新的变量时，赋的是该对象在栈中的内存地址，而不是堆中的数据。也就是两个对象**

#### **8. 立即执行函数（iife）和使用场景**

立即执行函数：`( function( ){ })( )` 返回值可以为基本数据类型，也能返会任何类型的值。

写法原因：因为在 javascript 里，括号内部不能包含语句，当解析器对代码进行解释的时候，先碰到了()， 然后碰到 function 关键字就会自动将()里面的代码识别为函数表达式而不是函数声明。

作用：立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量。

使用场景：

- 代码在页面加载完成之后，不得不执行一些设置工作，比如时间处理器，创建对象等等。
- 所有的这些工作只需要执行一次，比如只需要显示一个时间。
- 需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中， 不会让任何变量泄露成全局变量。

#### **9. 函数式编程含义**

函数式编程是一种强调以 **函数为主** 的软件开发风格。通过**组合纯函数**，**避免共享状态**、**可变作用和副作用**来构建软件的过程。

目的：**使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变**。

#### **10. bind 返回的函数可以作为构造函数吗？**

不可以，会报错的哦， `ERROR > Uncaught TypeError: s is not a constructor`

#### **11. 函数柯里化（卡瑞化、加里化）？**

**概念**：把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br/>
**容易理解的概念**：`Currying` 概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数（主要是利用闭包实现的）。<br/>
**特点**：

- 接收单一参数，将更多的参数通过回调函数来搞定
- 返回一个新函数，用于处理所有的想要传入的参数
- 需要利用 `call/apply` 与 `arguments` 对象收集参数
- 返回的这个函数正是用来处理收集起来的参数

**作用**：能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。<br/>
**用途**：我认为函数柯里化是对闭包的一种应用形式，延迟计算、参数复用、动态生成函数(都是闭包的用途)。

#### **12. 柯里化函数例子**

**柯里化函数**：把一个**_多参数的函数转化为单参数函数_**的方法。并且返回接受余下的参数而且返回结果的新函数的技术。
我的理解就是将一个接受多个参数的函数，转化为接收一个参数，并且不改变输出结果的一种办法。我觉得这就是 js 的柯里化函数

```js
// 简单的相加函数
var add = function (x,y) {
    return x + y
}
// 调用：
add(1,2)
​
// 柯里化以后
var add = function (x) { //柯里化函数(闭包)
    return function (y) {
        return x + y
    }
}
add(1)(2);
```

#### **13. 什么是高阶函数？**

高阶函数只是，将函数作为参数 ， 函数的返回值返回值是函数

```js
function higherOrderFunction(param, callback) {
  return callback(param);
}
```

#### **14. 谈谈 JS 的运行机制**

- `js` 是单线程的
  :::tip
  javaScript 语言的一大特点就是单线程，即同一时间只做一件事。
  :::
- `js` 的事件循环
  :::tip
  js 代码执行过程中会有很多任务，这些任务总的分成两类。

  - 同步任务
  - 异步任务

  需要注意的是除了同步任务和异步任务，任务还可以更加细分为`macrotask`(宏任务)和`microtask`(微任务)，js 引擎会优先执行微任务.

  **微任务**： `promise 的回调`、`node 中的 process.nextTick` 、`对 Dom 变化监听的 MutationObserver`。<br/>
  **宏任务**： `script 脚本的执行`、`setTimeout` ，`setInterval` ，`setImmediate 一类的定时事件`，还有如 `I/O` 操作、`UI 渲 染`等。

  :::

- js 是单线程运行的，代码执行的时候，通过将不同函数的执行上下文压入执行栈来保证代码的有序执行
- 在执行同步代码的时候，如果遇到了异步事件。js 引擎并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。
- 当同步事件执行完毕后，再将异步事件对应的回调加入到当前执行栈中不同的任务队列中等待执行。
- 任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕以后，js 引擎首先会判断微任务队列中是否有任务可执行，如果有就将微任务队首的事件压入栈中执行。
- 当微任务队列中的任务都执行完成后再去判断宏任务队列中的任务。

```js
setTimeout(function () {
  console.log(1);
}, 0);
new Promise(function (resolve, reject) {
  console.log(2);
  resolve();
}).then(function () {
  console.log(3);
});
process.nextTick(function () {
  console.log(4);
});
console.log(5);
```

输出结果：`2,5,4,3,1`

`第一轮：主线程开始执行，遇到 setTimeout，将 setTimeout 的回调函数丢到宏任务队列中，在往下执行 new Promise 立即执行，输出 2，then 的回调函数丢到微任务队列中，再继续执行，遇到 process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出 5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有 then 函数和 nextTick 两个微任务，先执行哪个呢？process.nextTick 指定的异步任务总是发生在所有异步任务之前，因此先执行 process.nextTick 输出 4 然后执行 then 函数输出 3，第一轮执行结束。 第二轮：从宏任务队列开始，发现 setTimeout 回调，输出 1 执行完毕，因此结果是 25431`

#### **15. 网页从输入网址到渲染完成经历了哪些过程？**

- 输入网址
- 发送到 DNS 服务，获取域名在 web 服务器相对应的 ip 地址
- 与 web 服务器建立 TCP 链接
- 浏览器向 web 服务器发送请求
- web 服务器响应请求，返回 url 数据（错误数据，以及重定向地址等）
- 浏览器下载 web 服务器返回的数据，解析 html 文件
- 生成 dom 树，解析 css/js 文件，渲染页面，直至完成

#### **16. 常见的内存泄漏**

- 意外的全局变量

  函数中意外的定义了全局变量，每次执行函数都会生成该变量，且不会随着函数执行结束而释放

- 未清除的定时器

  定时器没有清除，它内部引用的变量，不会被释放

- 脱离 **_DOM_** 的元素引用

  一个 dom 容器删除后，变量喂设置为 null,则其内部的 dom 元素则不会释放

- 持续绑定事件

  函数中 **_addEventListener_** 绑定事件，函数多次执行，绑定便会产生多次，产生内存泄漏。

- 闭包引起内存泄漏

  比如事件处理回调，导致 DOM 对象和脚本中对象双向引用。

- console.log

  console.log 的对象是不能被垃圾回收

#### **17. 如何解决跨域问题**

- 通过 jsonp 跨域
- document.domain + iframe 跨域
- location.hash + iframe
- window.name + iframe 跨域
- postMessage 跨域
- 跨域资源共享（CORS）
- nginx 代理跨域
- nodejs 中间件代理跨域
- WebSocket 协议跨域

#### **18. http 和 https 有何区别？**

- http 是 HTTP 协议运行在 TCP 至上。所有传输的内容都是明文，客户端和服务端都无法验证对方的身份。
- https 是 HTTP 运行在 SSL/TSL 之上，SSL/TSL 运行在 TCP 之上。所有传输的内容都经过加密，加密采用堆成加密，单堆成加密的密钥用服务器放的证书进行了非对称加密。
- 此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器也可以验证客户端的身份。

#### **19. 什么叫优雅降级和渐进增强**

- **渐进增强（Progressive Enhancement）**：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

- **优雅降级（Graceful Degradation）**：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

  其实渐进增强和优雅降级并非什么新概念，只是旧的概念换了一个新的说法。在传统软件开发中，经常会提到向上兼容和向下兼容的概念。渐进增强相当于向上兼容，而优雅降级相当于向下兼容。

- **区别**：优雅降级是从复杂的现状开始，并试图减少用户体验的供给，而渐进增强则是从一个非常基础的，能够起作用的版本开始，并不断扩充，以适应未来环境的需要。降级（功能衰减）意味着往回看；而渐进增强则意味着朝前看，同时保证其根基处于安全地带

#### **20. 什么是同源策略**

同源策略是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器额正常功能可能会受到影响。可以说 Web 是构建在同源策略的基础之上的，浏览器只是对同源策略的一种实现。

同源策略是浏览器的行为，是为了保护本地数据不被 JavaScript 代码获取回来的数据污染，因此拦截的是客户端发出的请求回来的数据接收，即请求发送了，服务器响应了，但是无法被浏览器接收。

**同源策略的作用：**
为了保护用户信息的安全，防止恶意的网络窃取
**什么是同源：**
端口、域名、协议相同
**安全限制具体都阻止了哪些东西不可以被访问：**

- 无法读取非同源策略下的 cookie、localstage
- 无法解除非同源的 dom
- 无法向非同源的地址发送 ajax 请求

**跨域访问：**

- 跨域访问的解决方案是 CORS!
- 也可以通过 **_window.postMessage_** 来实现，但不推荐，容易造成安全问题

#### **21. 浏览器是如何渲染页面的**

- 解析 HTML 文件，创建 DOM 树
  自上而下，遇到任何样式(link、style)与脚本(script) 都会阻塞 (外部样式不阻塞后续外部脚本的加载)
- 解析 CSS。优先级：浏览器默认设置 < 用户设置 < 外部样式 < 内联样式 < HTML 中的 style 样式
- 将 CSS 与 DOM 合并，构建渲染树(render tree)
- 布局和绘制，重绘(repaint) 和 重排(reflow)

#### **22. 请解释 JSONP 的工作原理，以及它为什么不是真正的 AJAX**

JSONP 是一种非正式传输协议，允许用户传递一个 callback 给服务端，然后服务端返回数据时会将这个 callback 参数作为函数名来包裹住 JSONP 数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。

当 GET 请求从后台页面返回时，可以返回一段 Javascript 代码，这段代码会自动执行，可以用来负责调用后台页面中的一个 callback 函数。

**为什么不是真正的 AJAX**

- 它们的实质不同
- ajax 的核心是通过 xmlHttpRequest 获取非本质内容
- jsonp 的核心是动态添加 script 标签调用服务器提供的 js 脚本
- jsonp 只支持 get 请求，ajax 支持 get 和 post 请求

#### **23. Object.assign()、扩展运算符（三点运算符）的区别**

- **_Object.assign()_** 是浅拷贝
- 扩展运算符第一层是深拷贝，其他的都是浅拷贝

#### **24. 介绍一下 js 的数据类型有哪些，值是如何存储的？**

**（1）数据类型**
基本数据类型：Number、Boolean、null、undefined、Symbol
引用数据类型：Object
**（2）如何存储**
原始数据类型：直接存储在栈中，占据空间小，大小固定，属于被频繁使用数据，所以放入栈中的存储。
引用数据类型：同时存储在栈和堆中，占据空间大，大小不固定。引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。

#### **25. map 和 Object 的区别**

| 项       | map                                      | object                                                       |
| :------- | :--------------------------------------- | :----------------------------------------------------------- |
| 意外的键 | 不包含任意键，只包含插入的键值           | 有一个原型、原型链的键名可能和自己在对象上设置的键名发生冲突 |
| 键的类型 | 任意的                                   | string、symbol                                               |
| 键的顺序 | 有序的，迭代的时候以其插入的顺序返回键值 | 无序的                                                       |
| size     | 可以通过 size 属性获取                   | 需要手动计算                                                 |
| 迭代     | 可迭代的                                 | 需要通过获取键来迭代                                         |
| 性能     | 在频繁增增删键值对的场景下表现更好       | 在频繁添加和删除键值对的场景下位作出优化                     |

#### **26. async 和 promise 的区别**

- Async/Await 代码看起来简洁一些，使得异步代码看起来像同步代码
- async await 与 Promise 一样，是非阻塞的。
- async await 是基于 Promise 实现的。，可以说是改良版的 Promise ,它不能用于普通的回调函数

#### **27. promise 有几种状态？如何变化**

三种状态： **_等待（pending）_**、**_已完成（fulfilled）_**、**_已拒绝（rejected）_**

promise 的状态只可能从等待转到完成或者拒绝态，不可逆转，同时完成态和拒绝态不能相互转换

状态的表现：

- pending: 不会触发 then 和 catch
- fulfilled: 会触发后续的 then
- rejected: 会触发后续的 catch
- then 正常返回 resolve，如果报错则返回 rejected
- catch 正常返回 resolve，如果报错则返回 rejoiced

#### **28. js 的数据类型的转换有哪些**

- 转为布尔值： **_Boolean()_**
- 转为数字： **_Number()_**、**_parselnt()_**、**_parseFloat()_**
- 转为字符串：**_toString()_**、**_String()_**

#### **29. document.ready 和 document.onload 的区别**

- ready 表示文档结构已经加载完成（不包含图片等非文字媒体文件），onload 表示页面包含图片等文件在内的所有元素都加载完成
- ready 可以多次使用，而 onload 只能有一个，如果出现多个的话后面的会自动话覆盖前面的函数

#### **30. 如何判断 js 的数据类型**

- **typeof**： 可以判断出 string、number、boolean、undefined、symbol、function、bigint,但判断 **_typeof(null)_** 时值为 'object';判断数组和对象时值均为'bject'
- **instanceof**: 可以判断一个实例是否属于某种类型，也可以判断一个实例是否是其父类型或者祖先类型的实例
- **constructor**: 除了 undefined 和 null 之外，其他类型都可以通过 constructor 来判断。但如果声明了一个构造函数，并且改变了它的原型执行，这种情况下 constructor 也不能准确判断
- **Object.prototype.toString**:判断一个对象只属于某类内置类型，但不能准确判断一个实例是否属于某种类型
- **Array.isArray**: 判断是否为数组

#### **31. 关于 js 事件冒泡与 js 事件代理（事件委托）**

- **事件冒泡:**

  当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 window，过程就像冒泡泡。如果在某一层想要终止冒泡，使用 **_event.stopPropagation()_**

  但是当大量标签大量事件的时候显然不可能为每个元素都加上事件，（事件绑定占用事件，浏览器要跟踪每个事件，占用更多内存。而且并不是所有事件都会被用户使用到）。所以需要事件委托来解决这个问题。

- **事件委托:**

  将事件给外层的元素，自己不实现逻辑，由最外层元素来代理。（判断事件源，做不同处理）

#### **32. 什么是宏任务和微任务，两者有什么区别？**

- **整个 JS 在运行过程中主要执行以下事件循环（Even loop）**
  - 主程序从上往下执行同步任务
  - 异步任务会被放入异步队列中
  - 当同步任务执行完成后，会去异步任务队列中执行异步事件
- **在异步任务中还有宏任务和微任务的区别**
  - 宏任务： **_setTimeout_**、**_setInterval_**、**_Ajax_**、**_DOM 事件_** 等
  - 微任务： **_promise_**、**_async/await_**、**_Object.observe_** 等
- **宏任务和微任务的执行顺序**
  - 同步任务->微任务->宏任务
- **两者的区别**
  - 宏任务： DOM 渲染后触发，如 **_setTimeout_**
  - 微任务： DOM 渲染前触发，如 **_promise_**

#### **33. 响应事件有哪些？**

- 鼠标单击事件
- 鼠标经过事件
- 鼠标移开事件
- 光标聚焦事件
- 失焦事件
- 内容选中事件
- 文本框内容改变事件
- 加载事件
- 卸载事件

#### **34. 什么是事件流？什么是事件冒泡？什么是事件捕获？**

- 事件流：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。
- 冒泡事件：事件按照从最特定的事件目标到最不特定的事件目标（document 对象）的顺序触发。
- 捕获事件：事件从最不精确的对象（document 对象）开始触发，然后到最精确（也可以在窗口级别捕获事件，不过必须由开发人员特别指定）。

在添加事件时用 addEventListener(event,fn,useCapture) 方法，基中第三个参数 useCapture 是一个 Boolean 值，用来设置事件是在事件捕获时执行，还是事件冒泡时执行。

注意： IE 浏览器用 attachEvent()方法，此方法没有相关设置，不过 IE 的事件模型默认时在事件冒泡时执行的，也就是在 useCapture 等于 false 的时候执行，所以把在处理事件时把 useCapture 设置为 false 是比较安全，也实现兼容浏览器的效果。

- ##### **如何阻止事件冒泡？**
  w3c 的方法是 e.stopPropagation()，IE 则是使用 e.cancelBubble = true，return false 也能阻止冒泡
- ##### **如何阻止默认事件？**
  w3c 的方法是 e.preventDefault()，IE 则是使用 e.returnValue = false，return false 也能阻止默认行为

#### **35. require 和 import 之间额区别**

| 项目     | require                                  | import                                                       |
| :------- | :--------------------------------------- | :----------------------------------------------------------- |
| 导出方法 | moudle.exports                           | export default/export                                        |
| 语法     | CommonJs 语法                            | ES6 语法标准                                                 |
| 加载顺序 | 运行时加载模块里面的所有方法（动态加载） | 编译的时候调用（静态加载），不管在哪里引用都会提升到代码顶部 |
| 引入对象 | 引入的是整个模块里面的对象               | 按需引入模块里面的对象                                       |
| 值       | 导出的是值的拷贝                         | 导出的是值的引用                                             |

#### **36. 栈和堆的区别**

| 项目         | 栈                                                                                                                 | 堆                                                           |
| :----------- | :----------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------- |
| 申请方式不同 | 系统自动分配                                                                                                       | 人为申请开辟                                                 |
| 申请大小不同 | 空间较小                                                                                                           | 空间较大                                                     |
| 申请效率不同 | 系统自动分配，速度较快                                                                                             | 速度比较慢                                                   |
| 存储内容不同 | 栈在函数调用时，函数调用语句的下一条可执行语句的地址第一个进栈，然后函数的各个参数进栈，其中静态变量是不可入栈的。 | 一般是在头部用一个字节存放堆的大小，堆中的具体内容是人为安排 |
| 底层不同     | 栈是持续的空间                                                                                                     | 堆是不连续的空间                                             |
| 生长方式不同 | 栈的生长方式向下，内存地址由高到低                                                                                 | 堆的生长方式向上，内存地址由低到高                           |
| 管理方式不同 | 栈由操作系统自动分配释放，无需我么手动控制                                                                         | 堆的申请和释放工作由程序员控制，容易产生内存泄漏             |

#### **37. forEach、for...in、for...in 的区别？**

- **forEach** 遍历数组，但不能使用 **_break_**、**_continue_**、**_return_** 语句
- **for...in** 是用来循环带有字符串 key 的对象的方法。实际是为循环 **enumerable** (可枚举)对象而设计的。Js 基本数据类型自带的原型属性不可枚举,通过 **_Object.defineProperty_** 方法指定 **enumeralbe** 为 **_false_** 的属性不可枚举。
- **for...in**循环出的是 **_key_**，**for…of**循环出的是 **_value_**。
- for…of 数组对象都可以遍历，它是 ES6 中新增加的语法。一个数据结构只有部署了 Symbol.iterator 属性, 才具有 iterator 接口可以使用 for…of 循环。for…of 遍历对象需要通过和 Object.keys()
- **哪些数据结构部署了 Symbol.iteratore 属性**
  - 数组 **Array**
  - **Map**
  - **Set**
  - **String**
  - **arguments** 对象
  - **Nodelist** 对象，就是获取的 **dom** 列表集合

#### **38. 对 ES6 的理解**

- 新增模版字符串（为 JavaScript 提供了简单的字符串插值功能）
- 箭头函数
- for...of（用来遍历数据---例如数组中的值）
- arguments 对象可被不定参数和默认参数完美代替
- ES6 将 promise 对象纳入规范，提供了原生的 promise 对象
- 增加了 let 和 const 命令，用来声明变量
- 增加了块级作用域
- let 命令实际上就增加了块级作用域
- 引入 module 模块的概念

#### **39. map 和 set 的区别**

- Map 是键值对，Set 是值的集合，键和值可以是任何值。
- Map 可以通过 get 方法获取值，而 set 不能因为它只有值，set 只能用 has 来判断，返回一个布尔值。
- Set 的值是唯一的可以做数组去重，Map 由于没有格式限制，可以做数据存储。

#### **40. JS 中的 === 和 == 的区别**

- 对于 string、number 等基础类型，== 和 === 有区别
  - 不同类型间比较，==只比较转化成同一类型后的值看值是否相等，===如果类型不同，其结果就是不等。
  - 同类型比较，直接进行值比较，两者结果一样。
- 对于 Array、Object 等高级类型，== 和 === 没有区别
  - 进行值真地址比较
- 基础类型与高级类型， == 和 === 有区别
  - 对于 == ，将高级转化为基础类型，进行值比较。因为类型不同， === 结果为 false

#### **41. 全局函数 eval() 有什么作用**

eval()只有一个参数，如果传入的参数不是字符串，它直接返回这个参数。如果参数是字符串，它会把字符串当成 javascript 代码进行编译。如果编译失败则抛出一个语法错误(syntaxError)异常。如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或语句的值，如果最后一个表达式或语句没有值，则最终返回 undefined。如果字符串抛出一个异常，这个异常将把该调用传递给 eval()。

#### **42. new 一个对象的过程**

- 创建一个新对象，新对象的隐式原型**proto**指向 new 的构造函数的显示原型 proptotype
- 改变 this 指向，将构造函数的作用域给新的对象，并且执行构造函数的代码，为新的对象提阿加属性
- 返回新的对象（return this）

#### **43. 原生对象和宿主对象**

原生对象是 ECMAScript 规定的对象，所有内置对象都是原生对象，比如 Array、Date、RegExp 等。

宿主对象是宿主环境比如浏览器规定的对象，用于完善是 ECMAScript 的执行环境，比如 Document、Location、Navigator 等

#### **44. Cookie、sessionStorage、localStorage 解释及其区别**

- **Cookie**

  Cookie 是一些数据，由服务器生成，发送给浏览器，一旦用户从该网站或服务器退出，Cookie 就存储在用户本地的磁盘上，下一次请求同一网站时会把该 cookie 发送给服务器。Cookie 的作用就是用于解决如何记录客户端的用户信息。

  可以使用 document.cookie 属性来创建、读取、及删除 cookie.

  Cookie 的内容主要包括： 名字 name，值 value，过期时间 expires，路径 path 和域 domain。路径和域一起构成 Cookie 的作用范围。一般 Cookie 存储在内存里，若设置了过期时间则存储在硬盘里，浏览器页面关闭也不会是小，直到设置的过期时间后才失效。若不设置 Cookie 过期时间，则有效期为浏览器窗口的会话期间，关闭浏览器就失效。

- **sessionStorage**

  sessionStorage 顾名思义，是在当前会话下有效，引入了一个浏览器窗口概念，sessionStorage 是在同源的同窗口中，始终存在数据，只要浏览器不关闭，即使刷新或者进入同源的另一个页面，数据仍在。同时打开独立的窗口，即使是同一个页面，sessionStorage 的对象也是不同的。关闭窗口后 sessionStorage 就会被销毁。

  可以使用 **_sessionStorage.setItem_**、**_sessionStorage.getItem_**、**_sessionStorage.removeItem_** 来创建 、读取、及删除 sessionStorage。

- **localStorage**

  localStorage 的生命周期是永久，除非手动去清除，否则永远都存在，他的储存大小是 5MB，仅在客户端浏览器上储存，不参与服务器的通信。

  可以使用 **_localStorage.setItem_**、**_localStorage.getItem_**、**_localStorage.removeItem_** 来创建 、读取、及删除 localStorage。

- **Cookie，sessionStorage，localStorage 的区别：**
  - 存储大小：Cookie 是 4KB，Storage 是 5M；
  - 有效期：Cookie 可以设置有效期，超过有效期自动清除；localStorage 永久存储，除非手动清除；sessionStorage 是会话缓存，关闭浏览器就会清除；
  - 存储位置：Cookie 会发送到服务器端，存储在内存中，Storage 只存储在浏览器端；
  - 作用域不同：sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；localstorage 在所有同源窗口中都是共享的；Cookie 也是在所有同源窗口中都是共享的
  - 存储内容： Cookie 只能保存字符串类型，以文本的方式。Storage 通过能支持任何类型的对象（Storage 中可含有多个对象）
  - API：Storage 的 API 接口使用更方便

#### **45. 什么是虚拟 DOM**

- **起源**

  虚拟 DOM 最先是由 facebook 团队提出的，最先运用在 react 中，之后在 vue2.0 版本中引入虚拟 DOM 的概念。

- **是什么**

  :::tip
  **虚拟 DOM 是相对于浏览器所渲染出来的真实 DOM 的**
  :::

  以往，我们改变更新页面，只能通过首先查到 dom 对象，再进行修改 dom 的方式来达到目的。**但是这种方式相当耗费计算资源，因为每次查询 dom，都需要遍历整颗 dom 树**

  现在，我们用对象的方式来描述真实的 dom，并且通过对象与真实 dom 建立了一一对应的关系，那么每次 dom 的更改，我通过找到相应对象，也就找到了相应的 dom 节点，再对其进行更新。这样的话，就能节省性能，因为**js 对象的查询，比对整个 dom 树的查询，所以消耗的性能更少**。

- **本质**

  Vnode 的本质就是用 **树型结构的 JS 对象** 来描述真实的 DOM 结构的信息，这个树结构的 JS 对象包含了整个 DOM 结构的信息。

  ```html
  <ui id="list">
    <li class="item">item1</li>
    <li class="item">item2</li>
  </ui>
  ```

  ```js
  {
    tag: "ul";
    attrs: {
      id: "list";
    },
    children:[
      {
        tag:'li',
        attrs:{
          className: 'item'
        },
        children:['item1']
      }, {
        tag:'li',
        attrs:{
          className: 'item'
        },
        children:['item2']
      }
    ]
  }
  ```

  可见上面的 DOM 结构，不论是标签名称还是标签的属性或标签的子集，都会对应在下边的树形结构里。

#### **46. 虚拟 DOM 的优缺点**

- **优点：**

  - **降低浏览器性能消耗**

    因为 **Javascript 的运算速度远大于 DOM 操作的执行速度**，因此，运用 `patching` 算法来计算出真正需要更新的节点，最大限度地减少 DOM 操作，从而提高性能。

    :::tip

    **在 vnode 技术出现之前**，我们要改变页面展示的内容 **只能通过遍历查询 dom 树的方式找到需要修改的 dom，然后修改样式行为或者结构**，来达到 **更新 ui** 的目的。这种方式 **相当消耗计算资源，** 因为每次查询 dom 几乎都需要遍历整颗 dom 树。

    :::

    :::tip

    **在 vnode 技术出现之后**，我们建立一个 **虚拟 dom 对象来对应真实的 dom 树，** 那么 **每次 dom 的更改就变成了 js 对象的属性的更改，** 这样一来就能查找 js 对象的属性变化要比查询 dom 树的性能开销小。

    :::

  - **diff 算法，减少回流和重绘**

    通过 diff 算法，优化遍历，对真实 dom 进行打补丁式的新增、修改、删除，实现局部更新，减少回流和重绘。

    :::tip
    vnode 优化性能核心思想，就是每次 **更新 dom 都尽量避免刷新整个页面，** 而是有针对性的去 **刷新那被更改的一部分，** 来释放掉被无效渲染占用的 gpu，cpu 性能。同时，也减少了大量的 dom 操作，减少了浏览器的回流和重绘。
    :::

  - **跨平台**

    **虚拟 DO 本质上是 JavaScript 对象，** 而 DOM 与平台强相关，相比之下虚拟 DOM，可以进行更方便地跨越平台操作，例如： `服务器渲染、weex开发` 等等。

- **缺点：**

  - **首次显示要慢些**

    首次渲染大量 DOM 时，由于多了一层虚拟 DOM 的计算名回避 innerHTML 插入慢。

  - **无法进行极致优化**

    虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中无法进行针对性的极致优化。

#### **47. 虚拟 DOM 的实现原理**

虚拟 dom 相当于 **在 js 和真实 dom 中间夹了一个缓存**，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。

具体实现步骤如下：

- 用 JavaScript 对象结构表示 DOM 树的结构，然后用这个树构建一个真正的 DOM 树，插到文档当中。
- 当状态变更的时候，重新构造一棵树的对象树，通过 diff 算法，比较新旧虚拟 DOM 树的差异。
- 根据差异，对真正的 DOM 树进行增、删、改。

#### **48. webpack 工作的过程**

解析配置参数，合并从`shell`(npm install 类似的命令)和`webpack.config.js` 文件的配置信息，输出最终的配置信息；

注册配置中的插件，让插件监听`webpack`构建生命周期中的事件节点，做出对应的反应；

解析配置文件中的 `entry` 入口文件，并找出每个文件依赖的文件，递归下去；

在递归每个文件的过程中，根据文件类型和配置文件中的 `loader` 找出对应的 `loader` 对文件进行转化；

递归结束后得到每个文件最终的结果，根据 `entry` 配置生成代码 `chunk`（打包之后的名字）；

输出所有 `chunk` 到文件系统。

#### **49. MVC 和 MVVM 区别**

- **MVC:**

  MVC 全名是 **Model View Controller** ，是 `模型-视图-控制器` 的缩写,一种软件设计典范。

  - **Model（模型）：** 是用于处理应用程序数据逻辑部分，通常模型对象负责在数据中存取数据。
  - **View（视图）：** 是应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。
  - **Controller（控制器）：** 是应用程序处理用户交互的部分，通常控制器负责从视图读取数据。控制用户输入，并向模型发送数据。

  **MVC** 的思想：一句话描述就是 **Controller** 负责将 **Model** 的数据用 **View** 显示出来，换句话说就是在 **Controller** 里面把 **Model** 的数据赋值给 **View** 。

- **MVVM：**

  MVVM 新增了 MV 类。

  - **Model：** 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供 api 的接口。
  - **View:** 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建。
  - **ViewModel：** 做了两件事达到了数据的双向绑定。
    - 将 `模型` 转换成 `视图`，即后端传递的数据转换成所看到的页面。实现的方式是：**_数据绑定_**。
    - 将 `视图` 转换成 `模型`，即将所看到的页面转换成后端的数据。实现的的方式是：**_DOM 事件监听_**。

- **MVVM** 与 **MVC** 的区别：
