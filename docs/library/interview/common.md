---
title: Web 零碎知识点
author: ecstAsy
date: "2022-02-09"
---

#### **1. 闭包(概念，作用，场景)**

- 概念：闭包就是能够读取其他函数内部变量的函数。例如在 javascript 中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。
- 作用：

#### **2. 函数节流**

- 概念： 在指定的时间内只会执行一次。
- 原理： 函数节流就是通过闭包保存一个标识 **(canDo = true)**，在函数开始时候判断这个标识是否为 **true** ,如果是 **true** 的话就继续执行函数，否则就 **return** 出去。判断完这个标识后，立即把这个 标识改为 **false** ，然后把外部传入的函数执行包在 **setTimeout** 中，最后在 **setTimeout** 执行完毕后，再把标识改为 **true** ，表示可以执行下一次任务了，在 **setTimeout** 没有执行完的时候，标识一直为 **false** ，在函数开头的时候会被 **return** 出去
- 代码：

```js
function throttle(fn, interval = 300) {
  let canDo = true;
  return () => {
    if (!canDo) return;
    setTimeout(() => {
      fn.apply(this, arguments);
      canDo = true;
    }, interval);
  };
}
```

- 场景：搜索引擎

#### **3. 函数防抖**

- 概念：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。
- 原理：函数防抖就是通过闭包保存一个标记来保存 **setTimeout** 返回的值，每当用户输入的时候把前一个 **setTimeout clear** 掉，然后又创建一个新的 **setTimeout**，这样就能保证输入字符后的 **interval** 间隔内如果还有字符输入的话，就不会执行 fn 函数了。
- 代码：

```js
function debounce(fn, interval = 300) {
  let timeout = null;
  return function () {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      fn.apply(this, arguments);
    }, interval);
  };
}
```

- 场景： 表单提交，付款

#### **4. Promise setTimeOut**

- 首先 Promise 构造函数会立即执行，而 Promise.then()内部的代码在当次事件循环的结尾立即执行(微任务)。
- promise 的状态一旦由等待 pending 变为成功 fulfilled 或者失败 rejected。那么当前 promise 被标记为完成，后面则不会再次改变该状态。
- resolve 函数和 reject 函数都将当前 Promise 状态改为完成，并将异步结果，或者错误结果当做参数返回。

#### **5. package.json 中，版本号前面的^和～**

- `~`: 匹配最新补丁版本号，也就是版本号的第三个数字。比如~1.2.3 将匹配所有 1.2.x 版本，但将在 1.3.0 上停止。
- `^`: 比较宽松，它匹配的是最新次要版本号，也就是第二个数字。比如：^ 1.2.3 将匹配任何 1.x.x 版本，包括 1.3.0，但将在 2.0.0 上停止。
- `*`: 匹配任意版本，一般不用
- `latest`: 安装的永远是最新的版本

#### **6. 堆(heap)和栈(stack)有什么区别存储机制**

- **栈(stack)**：**是一种连续储存的数据结构，具有先进后出后进先出的性质。**<br/>
  通常的操作有入栈（压栈），出栈和栈顶元素。想要读取栈中的某个元素，就是将其之间的所有元素出栈才能完成。

- **堆(heap)**：**是一种非连续的树形储存数据结构，具有队列优先,先进先出。**<br/>
  每个节点有一个值，整棵树是经过排序的。特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。常用来实现优先队列，存取随意。

#### **7. 什么是深拷贝，浅拷贝，浅拷贝 赋值的区别，如何实现**

:::tip
**深拷贝和浅拷贝是针对复杂数据类型来说的，浅拷贝只拷贝一层，而深拷贝是层层拷贝。**
:::

- **浅拷贝**

  - 将原对象或原数组的引用直接赋给新对象，新数组，新对象只是对原对象的一个引用，而不复制对象本身，新旧对象还是共享同一块内存
  - 如果**属性是一个基本数据类型，拷贝就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址**
  - 浅拷贝的实现方式
    - `object.assign()`
    - `lodash` 里面的 `_.clone`
    - `...`扩展运算符
    - `Array.prototype.concat`
    - `Array.prototype.clice`

- **深拷贝**
  - 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来，是“值”而不是“引用”
  - **深拷贝就是把一个对象，从内存中完整的拷贝出来，从堆内存中开辟了新区域，用来存新对象，并且修改新对象不会影响原对象**
  - 深拷贝的实现方式
    - `JSON.parse(JSON.stringify())`
    - **递归操作**
    - `cloneDeep`
    - `Jquery.extend()`
- **赋值**
  - 当我们把一个**对象赋值给一个新的变量时，赋的是该对象在栈中的内存地址，而不是堆中的数据。也就是两个对象**

#### **8. 立即执行函数（iife）和使用场景**

立即执行函数：`( function( ){ })( )` 返回值可以为基本数据类型，也能返会任何类型的值。

写法原因：因为在 javascript 里，括号内部不能包含语句，当解析器对代码进行解释的时候，先碰到了()， 然后碰到 function 关键字就会自动将()里面的代码识别为函数表达式而不是函数声明。

作用：立即执行函数会形成一个单独的作用域，我们可以封装一些临时变量或者局部变量，避免污染全局变量。

使用场景：

- 代码在页面加载完成之后，不得不执行一些设置工作，比如时间处理器，创建对象等等。
- 所有的这些工作只需要执行一次，比如只需要显示一个时间。
- 需要一些临时的变量，但是初始化过程结束之后，就再也不会被用到，我们可以用立即执行函数——去将我们所有的代码包裹在它的局部作用域中， 不会让任何变量泄露成全局变量。

#### **9. 函数式编程含义**

函数式编程是一种强调以 **函数为主** 的软件开发风格。通过**组合纯函数**，**避免共享状态**、**可变作用和副作用**来构建软件的过程。

目的：**使用函数来抽象作用在数据之上的控制流和操作，从而在系统中消除副作用并减少对状态的改变**。

#### **10. bind 返回的函数可以作为构造函数吗？**

不可以，会报错的哦， `ERROR > Uncaught TypeError: s is not a constructor`

#### **11. 函数柯里化（卡瑞化、加里化）？**

**概念**：把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br/>
**容易理解的概念**：`Currying` 概念其实很简单，只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数（主要是利用闭包实现的）。<br/>
**特点**：

- 接收单一参数，将更多的参数通过回调函数来搞定
- 返回一个新函数，用于处理所有的想要传入的参数
- 需要利用 `call/apply` 与 `arguments` 对象收集参数
- 返回的这个函数正是用来处理收集起来的参数

**作用**：能进行部分传值，而传统函数调用则需要预先确定所有实参。如果你在代码某一处只获取了部分实参，然后在另一处确定另一部分实参，这个时候柯里化和偏应用就能派上用场。<br/>
**用途**：我认为函数柯里化是对闭包的一种应用形式，延迟计算、参数复用、动态生成函数(都是闭包的用途)。

#### **12. 柯里化函数例子**

**柯里化函数**：把一个**_多参数的函数转化为单参数函数_**的方法。并且返回接受余下的参数而且返回结果的新函数的技术。
我的理解就是将一个接受多个参数的函数，转化为接收一个参数，并且不改变输出结果的一种办法。我觉得这就是 js 的柯里化函数

```js
// 简单的相加函数
var add = function (x,y) {
    return x + y
}
// 调用：
add(1,2)
​
// 柯里化以后
var add = function (x) { //柯里化函数(闭包)
    return function (y) {
        return x + y
    }
}
add(1)(2);
```

#### **13. 什么是高阶函数？**

高阶函数只是，将函数作为参数 ， 函数的返回值返回值是函数

```js
function higherOrderFunction(param, callback) {
  return callback(param);
}
```

#### **14. 谈谈 JS 的运行机制**

- `js` 是单线程的
  :::tip
  javaScript 语言的一大特点就是单线程，即同一时间只做一件事。
  :::
- `js` 的事件循环
  :::tip
  js 代码执行过程中会有很多任务，这些任务总的分成两类。

  - 同步任务
  - 异步任务

  需要注意的是除了同步任务和异步任务，任务还可以更加细分为`macrotask`(宏任务)和`microtask`(微任务)，js 引擎会优先执行微任务.

  **微任务**： `promise 的回调`、`node 中的 process.nextTick` 、`对 Dom 变化监听的 MutationObserver`。<br/>
  **宏任务**： `script 脚本的执行`、`setTimeout` ，`setInterval` ，`setImmediate 一类的定时事件`，还有如 `I/O` 操作、`UI 渲 染`等。

  :::

- js 是单线程运行的，代码执行的时候，通过将不同函数的执行上下文压入执行栈来保证代码的有序执行
- 在执行同步代码的时候，如果遇到了异步事件。js 引擎并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。
- 当同步事件执行完毕后，再将异步事件对应的回调加入到当前执行栈中不同的任务队列中等待执行。
- 任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕以后，js 引擎首先会判断微任务队列中是否有任务可执行，如果有就将微任务队首的事件压入栈中执行。
- 当微任务队列中的任务都执行完成后再去判断宏任务队列中的任务。

```js
setTimeout(function () {
  console.log(1);
}, 0);
new Promise(function (resolve, reject) {
  console.log(2);
  resolve();
}).then(function () {
  console.log(3);
});
process.nextTick(function () {
  console.log(4);
});
console.log(5);
```

输出结果：`2,5,4,3,1`

`第一轮：主线程开始执行，遇到 setTimeout，将 setTimeout 的回调函数丢到宏任务队列中，在往下执行 new Promise 立即执行，输出 2，then 的回调函数丢到微任务队列中，再继续执行，遇到 process.nextTick，同样将回调函数扔到为任务队列，再继续执行，输出 5，当所有同步任务执行完成后看有没有可以执行的微任务，发现有 then 函数和 nextTick 两个微任务，先执行哪个呢？process.nextTick 指定的异步任务总是发生在所有异步任务之前，因此先执行 process.nextTick 输出 4 然后执行 then 函数输出 3，第一轮执行结束。 第二轮：从宏任务队列开始，发现 setTimeout 回调，输出 1 执行完毕，因此结果是 25431`
