---
title: 前端 javascript
author: ecstAsy
date: "2022-04-12"
---

#### **1. this 的指向问题**

[this 指向文摘](../../library/javascript/js-this.md)

#### **2. JavaScript 有哪些垃圾回收机制？**

- 标记清除（ mark and sweep）
  这是 JavaScript 最常见的垃圾回收方式。当变量进入执行环境的时候，比如在函数中声明一个变量，垃圾回收器将其标记为“进入环境”。当变量离开环境的时候（函数执行结束），将其标记为“离开环境”。垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量，以及被环境中变量所引用的变量（闭包）的标记。在完成这些之后仍然存在的标记就是要删除的变量。
- 引用计数（ reference counting）
  在低版本的 E 中经常会发生内存泄漏，很多时候就是因为它采用引用计数的方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数。当声明了一个变量并将个引用类型赋值给该变量的时候，这个值的引用次数就加 1.如果该变量的值变成了另外一个，则这个值的引用次数减 1.当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问。因此，可以将它占用的空间回收，这样垃圾回收器会在运行的时候清理引用次数为 0 的值占用的空间在正中虽然 JavaScript 对象通过标记清除的方式进行垃圾回收，但是 BOM 与 DOM 对象是用引用计数的方式回收垃圾的。 也就是说，只要涉及 BOM 和 DOM，就会出现循环引用问题

#### **3. 列举几种类型的 DOM 节点**

| 节点          | 解释                                              |
| :------------ | :------------------------------------------------ |
| **Document**  | 整个文档是一个文档（ **Document** ）节点          |
| **Element**   | 每个 HTML 标签是一个元素（ **Element** ）节点     |
| **Attribute** | 每一个 HTML 属性是一个属性（ **Attribute** ）节点 |
| **Text**      | 包含在 HTML 元素中的文本是文本（ **Text** ）节点  |

#### **4. 谈谈 script 标签中 defer 和 async 属性的区别**

- **defer**属性规定是否延迟执行脚本，直到页面加载为止， **async** 属性规定脚本一旦可用，就异步执行。
- **defer** 并行加载 **JavaScript** 文件，会按照页面上 **script** 标签的顺序执行， **async** 并行加载 **JavaScript** 文件，下载完成立即执行，不会按照页面上 **script** 标签的顺序执行。

#### **5. 闭包**

使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染；缺点是闭包会常驻内存，增加内存使用量，使用不当很容易造成内存泄漏。在 **JavaScript** 中，函数即闭包，只有函数才会产生作用域。

闭包有 3 个特性

- 函数嵌套函数
- 在函数内部可以引用外部的参数和变量
- 参数和变量不会以垃圾回收机制回收

  **注：** [闭包](../../library/javascript/js-closure.md)

#### **6. 解释一下 unshift() push() 方法**

- **unshift()** 在数组前面添加元素

```js
const arr = ["Lily"];
arr.unshift("Tom", "Jane");
console.log(arr); // ['Tom', 'Jane', 'Lily']
```

- **push()** 在数据后面添加元素

```js
const arr = ["Lily"];
arr.push("Tom", "Jane");
console.log(arr); // ['Lily', 'Tom', 'Jane']
```

#### **7. encodeURL()和 decodeURL()的作用**

- encodeURI()用于将 URL 转换为十六进制编码
- decodeURI()用于将编码的 URL 转换回正常 URL

#### **8. 为什么不建议在 JavaScript 中使用 innerHTML？**

通过 **innerHTML** 修改内容，每次都会刷新，因此很慢。在 **innerHTML** 中没有验证的机会，因此更容易在文档中插入错误代码，使网页不稳定。

#### **9. 如何在不支持 JavaScript 的旧浏览器中隐藏 JavaScript 代码？**

- 在< script>标签之后的代码中添加“<！--”，不带引号。
- 在< /script>标签之前添加“//-->”，代码中没有引号。
- 旧浏览器现在将 JavaScript 代码视为一个长的 HTML 注释，而支持 JavaScript 的浏览器则将"<！-"和"//-->"作为一行注释。

#### **10. 如何实现浏览器内多个标签页之间的通信？**

调用 **localstorge**、 **cookie** 等数据存储通信方式

#### **11. null 和 undefined 的区别是什么？**

- **null** 是一个表示“无”的对象，转为数值时为 0；
- **null** 用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。
- **undefined** 是一个表示“无”的原始值，转为数值时为 **NaN**。
- 当声明的变量还未初始化时，变量的默认值为 **undefined** 。

:::tip
**undefined** 表示“缺少值”，即此处应该有一个值，但是还没有定义，典型用法是如下。

- 如果变量声明了，但没有赋值，它就等于 **undefined**。
- 当调用函数时，如果没有提供应该提供的参数，该参数就等于 **undefined**。
- 如果对象没有赋值，该属性的值为 **undefined**。
- 当函数没有返回值时，默认返回 **undefined**。

**null** 表示“没有对象”，即此处不应该有值，典型用法是如下

- 作为函数的参数，表示该函数的参数不是对象。
- 作为对象原型链的终点。

:::

#### **12. new 操作符的作用是什么**

- 创建一个空对象
- 由 **this** 变量引用该对象
- 该对象继承该函数的原型（更改原型链的指向）
- 把属性和方法加入到 **this** 引用的对象中
- 新创建的对象由 **this** 引用，最后隐式地返回 **this**

```js
const obj = {};
obj.__proto__ = Base.prototype;
Base.call(obj);
```

#### **13. JavaScript 延迟加载的方式有哪些**

包括 **defer** 和 **async**、动态创建 **DOM**（创建 **script**，插入 **DOM** 中，加载完毕后回调、按需异步载入 **JavaScript**。）

#### **14. call()和 apply()的区别和作用是什么**

- 作用
  - 都是在函数执行的时候，动态改变函数的运行环境（执行上下文）。
  - **call** 和 **apply** 的第一个参数都是改变运行环境的对象
- 区别
  - **call** 从第二个参数开始，每一个参数会依次传递给调用函数；
  ```js
  func.call(funcl, var1, var2, var3);
  ```
  - **apply** 的第二个参数是数组，数组的每一个成员会依次传递给调用函数。
  ```js
  func.apply(funcl, [var1, var2, var3]);
  ```

#### **15. 哪些操作会造成内存泄漏？**

内存泄漏指不再拥有或需要任何对象（数据）之后，它们仍然存在于内存中。

- 提示：
  - 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的唯一引用是循环的，那么该对象占用的内存立即被回收。
  - 如果 setTimeout 的第一个参数使用字符串而非函数，会引发内存泄漏闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）等会造内存泄漏。

#### **16. 列举 IE 与 firefox 的不同之处**

|         | style              | text            | 透明度滤镜                       | 事件                 | 鼠标位置          | event                | 要消除 list 的原点                            | CSS 圆角           |
| :------ | :----------------- | :-------------- | :------------------------------- | :------------------- | :---------------- | :------------------- | :-------------------------------------------- | :----------------- |
| IE      | **currentStyle**   | **innerText**   | **filter:alpha（ opacity=num）** | **attachEvent**      | **event.clientX** | **event.srcElement** | **margin：0**                                 | IE7 以下不支持圆角 |
| Firefox | **getComputStyle** | **textContent** | **-moz- opacity :num**           | **addEventListener** | **event.pageX**   | **event.target**     | **margin：0、 padding：0 和 list-style:none** | 都支持             |

#### **17. JavaScript 对象的几种创建方式**

- Object 构造函数式
- 对象字面量式
- 工厂模式
- 安全工厂模式
- 构造函数模式
- 原型模式
- 混合构造函数和原型模式
- 动态原型模式
- 寄生构造函数模式
- 稳妥构造函数模式
