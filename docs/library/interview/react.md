---
title: React 零碎知识点
author: ecstAsy
date: "2022-04-15"
---

### **_一. 组件基础_**

### **_二. 数据管理_**

### **_三. 生命周期_**

### **_四. 组件通信_**

#### **1. 父子组件的通信方式**

- 父组件向子组件通信：**父组件通过 props 向子组件传递需要的信息**

```jsx
// 子组件
const Child = (props) => <span>{props.name}</span>;
// 父组件
const Parent = () => <Child name="react" />;
```

- 子组件向父组件通信：**props + 回调函数方式传递信息**

```jsx
// 子组件
const Child = (props) => {
  const cb = (info) => props.callback(info);
  return <span onClick={() => cb("hi")}>{props.name}</span>;
};
// 父组件
const Parent = () => {
  const callback = (info) => {
    console.log(info); // hi
  };
  return <Child name="react" callback={callback} />;
};
```

#### **2. 跨级组件的通信方式**

父组件向子组件的子组件传递信息

- 使用 **_props_**，利用中间组件层层传递，但是如果父组件结构较深，那么中间每一层组件都要去传递 props，增加了复杂度，并且这些 props 并不是中间组件需要的
- 使用 **_context_**，context 相当于一个大容器，可以把要通信的内容放在容器中，这样不管嵌套多深，都可以随意取用，对于跨越多层的全局数据可以使用 context 实现

[context 实现组件通信原理](../react/context.md)

#### **3. 非嵌套关系组件的通信方式**

**非嵌套关系组件**是指没有任何包含关系的组件，包括兄弟组件以及不在同一个父级组件中的非兄弟组件

- 可以通过自定义事件通信（发布订阅模式）
- 可以通过 Redux 等进行全局状态管理
- 如果是兄弟组件通信，可以找到这两个兄弟节点共同的父节点，结合父子组件的通信方式进行通信

#### **4. 如何解决 props 层级过深的问题**

- 使用 **context API** ：提供一种组件之间的状态共享，而不必通过显式组件树逐层传递 **props**
- 使用 **Redux** 等状态库

#### **5. 组件通信的方式有哪些**

- **父组件向子组件通信**：父组件可以向子组件通过**_props_**的方式，向子组件通信
- **子组件向父组件通信**：**_props+回调函数_**的方式，父组件向子组件传递**props**进行通讯，次**props**作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数传递给父组件
- **兄弟组件通信**： 找到这两个兄弟节点共同的父节点，结合上面的两种方式由父节点转发信息进行通信
- **跨层级通信**：**_Context_**设计目的是为了共享那些对于一个组件树而言是**全局**的数据，例如当前认证用户、主题或首选语言、对于跨越多层的全局数据通过**Context**通信再适合不过
- **发布订阅模式**：发布者发布事件，订阅监听事件并做出反应，我们可以引入 **event**模块进行通信
- **全局状态管理工具**：借助**_Redux_**或**_Mobx_**等全局状态管理工具进行通信，这种工具会维护一个全局中心的**_Store_**，并根据不同的事件产生新的状态

### **_五. 路由_**

### **_六. Redux_**

### **_七. Hooks_**

### **_八. 虚拟 DOM_**

### **_九. 其他_**
