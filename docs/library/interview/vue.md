---
title: Vue 零碎知识点
author: ecstAsy
date: "2022-02-07"
---

#### **1. Vue 优点**

- 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb
- 简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习
- 双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单
- 组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势
- 视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作
- 虚拟 DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式
- 运行速度更快:相比较与 react 而言，同样是操作虚拟 dom，就性能而言，vue 存在很大的优势

#### **2. Vue 响应式实现原理**

- 接收 **data** 对象并监听 **data** 变化，遍历此对象所有的 **property** ,并使用 **Object.defineProperty()** 把这些 **property** 全部转为 **getter/setter** 在内部 **getter/setter** 让 Vue 能够追踪依赖在 property 被访问和修改时通知变更
- 每一个 **Component** 实例都对应一个 **watcher** 实例，它会在组件渲染的过程中把“接触”过的数据 **property** 记录为依赖。之后当依赖项的 **setter** 触发时，会通知 **watcher**，从而使它关联的组件重新渲染

![自动获取 input 框焦点](../../assets/data.png)

#### **3. Vue 数据双向绑定实现**

- **Vue** 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；
- 核心：关于 **Vue** 双向数据绑定，其核心是 **Object.defineProperty()** 方法

#### **4. Vue 的两个核心点**

- **数据驱动:** **ViewModel** 保证数据和视图的一致性
- **组件系统:** 应用类 **UI** 可以看作全部是由组件树构成

#### **5. Vue 常见指令**

- **v-show/v-if:** 控制节点的显示隐藏
- **v-for:** 数据遍历
- **v-model:** 双向数据绑定
- **v-on:click/@click:** 事件绑定 **v-on** 可以一次绑定多个事件
- **v-bind/:info:** 数据绑定
- **v-once:** 只绑定一次

#### **6. Vue 数据传递**

- 父组件向子组件传递：**props**
- 子组件向父组件传递：**$emit**

#### **7. v-show 和 v-if 区别**

- 共同点：都是控制元素的显示和隐藏
- 不同点：本质方法不同
- **v-show**: 通过 **CSS** 中的 **display** 是否为 **none**，来控制元素的显示与隐藏，且只会编译一次
- **v-if**: 动态的向 **DOM** 树添加或删除 **DOM** 元素，如果初始值设置为 **false** ,则不会编译。且不停的销毁和创建 **DOM** 元素，比较消耗性能
- 如果需要频繁的切换某节点，使用 **v-show** 更优（初始开销大，切换开销小），如果不需要频繁切换某节点，则使用 **v-if** 更优（初始开销小，切换开销大）

:::tip

**扩展补充：display: none、visibility: hidden 和 opacity: 0 之间的区别**

| 项目           | display: none                                            | visibility: hidden                                                    | opacity: 0                                                     |
| :------------- | :------------------------------------------------------- | :-------------------------------------------------------------------- | :------------------------------------------------------------- |
| 是否占据空间   | 隐藏后不占位置                                           | 隐藏后仍然占位置                                                      | 隐藏后仍然占位置                                               |
| 子元素是否继承 | 不会被子元素继承，父元素都不存在了，子元素也不会显示出来 | 会被子元素继承，通过设置子元素 **_visibility: visible_** 来显示子元素 | 会被子元素继承，但是不能设置子元素 **_opacity: 1_** 来重新显示 |
| 事件绑定       | 元素不存在了，因此无法触发它绑定的事件                   | 不会触发它上面绑定的事件                                              | 元素上面绑定的事件可以被触发                                   |
| 过度动画       | **_transition_** 对于 **display** 是无效的               | **_transition_** 对于 **visibility** 是无效的                         | **_transition_** 对于 **opacity** 是有效的                     |

:::

#### **8. CSS 只在当前组件生效**

在组件的 **style** 前面添加 **scoped**

#### **9. keep-alive 作用**

**keep-alive** 是 **Vue** 的内置组件，可以使被包含的组件保留状态，避免被重新渲染

#### **10. 如何获取 DOM**

给节点添加 **ref=domName** 属性，通过 **this.$refs.domName** 获取

#### **11. Key 的作用**

每个节点的唯一标识，**Diff** 算法就可以正确识别此节点，高效的更新虚拟 **DOM**

#### **12. v-model 的使用**

用于表单数据的双向绑定，其实就是一个语法糖，实际上就是 **v-bind** 指令绑定一个 **value** 属性，**v-on** 指令给当前元素绑定 **input** 事件

#### **13. computed 和 watch 使用场景**

- **computed:** 当一个属性受多个属性影响的时候 🌰：**购物车商品结算的时候**
- **watch:** 当一个属性影响多个属性的时候 🌰：**搜索数据**

#### **14. $nextTick 的使用**

当你修改了 **data** 的值然后马上获取这个 **DOM** 元素的值，是不能获取到更新后的值，你需要使用 **$nextTick** 这个回调，让修改后的 **data** 值渲染更新到 **DOM** 元素之后在获取，才能成功

#### **15. data 为什么必须是一个函数**

因为 **JavaScript** 的特性所导致，在 **Component** 中，**data** 必须以函数的形式存在，不可以是对象。 组件中的 **data**写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 **data** ，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个 **data** ，这样改一个全都改了。

#### **16. v-if 和 v-for 的优先级**

当 **v-if** 与 **v-for** 一起使用时，**v-for** 具有比 **v-if** 更高的优先级，这意味着 **v-if** 将分别重复运行于每个 **v-for** 循环中。所以，不推荐 **v-if** 和 **v-for** 同时使用。 如果 **v-if** 和 **v-for** 一起用的话，**Vue** 中的的会自动提示 **v-if** 应该放到外层去
Vue 3.0 对 **v-if** 和 **v-for** 做了权重比较，可以混合使用

#### **17. vue 常用的修饰符**

- **.stop :** 等同于 **JavaScript** 中的 **event.stopPropagation()** ,防止事件冒泡
- **.prevent :** 等同于 **JavaScript** 中的 **event.preventDefault()** ,防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）
- **.capture :** 冒泡事件的方向相反，事件捕获由外到内
- **.self :** 只触发自己范围内的事件，不包含子元素
- **.once :** 只会触发一次
- **.keyup :** 按键修饰符
- **.passive :** 滚动事件的默认行为 (即滚动行为) 将会立即触发(提升移动端性能)

#### **18. vue-router 跳转和 location.href 的区别**

- **location.href** 跳转简单方便，但是刷新了页面
- **history.pushState(’/url’)** 无刷新页面，静态跳转
- **router.push('/url')** 使用 **diff** 算法，实现按需加载，减少 **DOM** 消耗
- 在 **history** 下，**history.pushState(’/url’)** 和 **router.push('/url')** 是一样的，因为 **vue-router** 就是用了**history.pushState()**

#### **19. vue-router 如何定义动态路由，怎么获取参数**

- 在 **router** 目录下的 **index.js** 文件中，对 **path** 属性加上 **/:id**
- 使用 **router** 对象的 **params.id**

#### **20. assets 和 static 的区别**

- 两者都是存放静态资源文件
  - 图片
  - 字体图标
  - 样式文件
- **assets:** 存放的静态资源在进行 **npm run build** 打包时会将 **assets** 中存放的文件进行打包压缩，代码格式化，并且压缩后的文件都会放在 **static** 文件中跟随 **index.html** 上传至服务器
- **static:** 存放的静态资源不会走打包压缩格式化流程，而是直接上传至服务器,对比 **assets** 文件，体积较大，上传至服务器会占据更大的空间
- **建议：** 项目中 **template** 的 **css、js** 文件最好都放到 **assets** 中，进行压缩和格式化，减少体积。而对于第三方的资源文件或者 **iconfont** 这些都是经过压缩处理过的，可以直接放在 **static** 中

#### **21. slot 的作用**

**slot** 插槽，它的作用即父组件内放了一些 **DOM** , 这些 **DOM** 是显示还是不显示，在哪里显示，如何显示，这就是 **slot** 的分发作用

#### **22. router-link 在电脑上有用，在安卓上没反应**

**Vue** 路由在 **Android** 机上有问题，**babel** 问题，安装 **babel polypill** 插件解决

#### **23. Vue2 中注册在 router-link 上事件无效**

使用 **@click.native** 原因：**router-link** 会阻止 **click** 事件，**.native** 指直接监听一个原生事件

#### **24. vue-loader 作用**

它是 **webpack** 的一个 **loader** ，用于处理 **.vue** 文件，将 **template/style/js** 转换成 js 模块

- js => es6/7/8/9
- style => sass/scss/less
- template => html

#### **25. vue 项目是打包了一个 js 文件，一个 css 文件，还是有多个文件**

根据 **vue-cli** 脚手架规范，一个 **js** 文件，一个 **CSS** 文件

#### **26. vuex 有哪几种属性**

- state
- getter
- mutation
- action
- module

#### **27. vuex 中的 store 特性**

- **vuex** 就像是一个仓库，仓库里面放了很多对象。其中 **state** 就是数据源存放地，对应 **vue** 里面的 **data**
- **state** 里面存放的数据源是响应式的，**vue** 组件从 **store** 读取数据，若是 **store** 中的数据发生变化，依赖这组数据的组件也会发生更新
- 它通过 **mapState** 把全局的 **state** 和 **getter** 映射到当前组件的 **computed** 中

#### **28. vuex 中的 getter 的特性**

- **getter** 可以对 **state** 进行计算操作，它就是 **store** 的计算属性
- 虽然在组件内也可以做计算属性，但是 **getters** 可以在多个组件内复用
- 如果一个状态只在一个组件内使用，是可以不用 **getters**

#### **29. vuex 中的 mutation 的特性**

**action** 类似于 **mutation** ,但是 **action** 提交的是 **mutation** , 而不是直接变更状态， **action** 可以包含任意异步操作

#### **30. vue 中的 ajax 请求是应该写在组件还是 action 中**

如果请求的数据不被其他组件公用，仅仅在组件内部使用，既不需要放在 **vuex** 的 **state** 中。 如果请求的数据被多个组件公用的话，请将请求放在 **action** 中，方便数据复用，并包裹成 **Promise** 返回

#### **31. 为什么要使用 vuex**

- 提高代码的可维护性，方便修改数据，使用 **vuex** 修改数据时只用修改一处，反之你需要修改三处
- 提升代码的可读性，因为一个组件里面的数据你看不出是从哪里来的
- 降低耦合度，本来 **Vue** 的 **Component** 就是为了减少耦合，如果不用 **Vuex** 会大量的上传派发，会让耦合度大大增加

#### **32. vue 中有处理过内存泄露问题吗**

- 意外的全局变量

  函数中意外的定义了全局变量，每次执行函数都会生成该变量，且不会随着函数执行结束而释放。

- 未清除的定时器

  定时器没有清除，它内部引用的变量，不会被释放。

- 脱离 DOM 的元素引用

  一个 DOM 容器删除之后，变量未置为 null ，则其内部的 DOM 元素则不会释放。

- 持续绑定的事件

  函数中 `addEventListener` 绑定事件，函数多次执行，绑定便会产生多次，产生内存泄漏。

- 绑在 `EventBus` 的事件没有解绑
- 闭包引起内存泄漏

  比如事件处理回调，导致 DOM 对象和脚本中对象双向引用。

- 使用第三方库创建，导致 DOM 对象和脚本对象双向引用
- 单页应用时，页面路由切换，内存未释放

#### **33. Eventloop 事件循环机制**

- 将 **执行栈** 最开始的同步代码（宏任务）执行完成。
- 检查是否有微任务，如有则执行所有的微任务。
- 取出 **任务队列** 中事件所对应的回调函数，（宏任务）进入 **执行栈** 并执行完成。
- 再检查是否有微任务，如有则执行所有的微任务。
- 主线程不断重复上面的两个（3，4）步骤

**宏任务**：`同步代码`，`setTimeout`，`setInterval`，`requestAnimationFrame`，`I/O`，`UI rendering`

**微任务**：`process.nextTick`，`promise callback`，`MutationObserver`

#### **34. Vue 的 axios**

`axios` 是一个基于 `Promise` 用于浏览器和 `nodejs` 的 `HTTP` 客户端，它本身具有以下特征：

- 从浏览器中创建 `XMLHttpRequest`
- 从 `node.js` 发出 `http` 请求
- 支持 `Promise API`
- 拦截请求和响应
- 转换请求和响应数据
- 取消请求
- 自动转换 `JSON` 数据
- 客户端支持防止 `CSRF/XSRF`

#### **35. vue-router 的两种模式**

- `hash` 模式
  - 使用 `URL` 的 `hash` 来模拟一个完整的 URL,于是当 URL 改变的时候,页面不会重新加载,也就是单页应用
  - 当 `#` 后面的 hash 发生变化时,不会导致浏览器向服务器发出请求,浏览器不发出请求就不会刷新页面,并且会触发 `hasChange` 这个事件,通过监听 hash 值的变化来实现更新页面部分内容的操作
- `history` 模式: 主要使用 `HTML5` 的 **_pushState()_** 和 **_replaceState()_** 这两个 api 来实现的
  - **_pushState()_** 可以改变 url 地址且不会发送请求
  - **_replaceState()_** 可以读取历史记录栈,还可以对浏览器记录进行修改
- 前面的 `hashchange`，你只能改变#后面的 url 片段。而 `pushState` 设置的新 URL 可以是与当前 URL 同源的任意 URL。
  history 模式则会将 URL 修改常请求后端的 URL 一样,如后端没有配置对应/user/id 的路由处理，则会返回 404 错误

#### **36. 父子组件生命周期执行顺序**

父 beforecreate -> 父 created -> 父 beforeMount -> 子 beforecreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted

- 1. 当父组件执行完 **beforeMount** 挂载开始后，会依次执行子组件的生命周期钩子，直到全部子组件 **mounted** 挂载到实例上，父组件才会进入 **mounted** 钩子。
- 2. 子组件触发事件，会先触发父级 **beforeUpdate** 钩子，再去触发子级 **beforeUpdate** 钩子，下面又是先执行子级 **update** 钩子，后执行父级 **update** 钩子。

**总结：** 父组件先于子组件 **created**，而子组件先于父组件 **mounted** 从外到内，再从内到外。

#### **37. vue 中子组件调用父组件的方法**

- 在子组件中通过 **this.$parent.event** 来调用父组件方法
- 在子组件里面用 **$emit** 向父组件触发一个事件，父组件监听这个事件
- 父组件把方法传入子组件，在组件里面直接调用这个方法

#### **38. vue 双向绑定原理**

- 通过 **v-model** 可以实现双向绑定
- 采用数据劫持和发布者-订阅模式的方式
- 通过 **Object.defineProperty()** 来劫持各个的 **set()** 设置， **get()** 获取
- 触发相应的监听回调来渲染视图

Vue3.0 采用原生 **Proxy** 替换 **Object.defineProperty()**

#### **39. 为什么要替换 Object.defineProperty()**

- **Object.defineProperty()** 只能遍历对象属性进行劫持
- **Proxy** 直接可以劫持整个对象，并返回一个新对象，我么可以直接操作新的对象达到响应式目的

:::tip
在 Vue 中 ，**Object.defineProperty()** 无法监控到数组下标的变化，导致直接通过数组下标给数组设置值，不能实时响应。

**Object.defineProperty()** 只能劫持对象的属性，因此我们需要对每个对象的每个属性进行遍历。
:::

#### **40. Vue 生命周期四个初始化阶段方法**

- **beforeCreate()** : 创建 vue 之前执行 （数据和虚拟 DOM 树还没有加载完成）
- **created()** : 创建 vue 之前执行 （数据已经加载好，虚拟 DOM 树没有加载完成）
- **beforeMount()** : 页面渲染之前执行 （数据和虚拟 DOM 树都已经加载好，但是数据这时并没有填充）
- **mounted()** : 页面渲染之后 （数据已经填充完成）

#### **41. 怎样理解 Vue 的单向数据流**

所有的 prop 都使得其父子 prop 之间形成一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。

额外的，每次父组件发生更新时，子组件中所有的 prop 都将会刷新的值。这意味着你不应该再一个子组件内部改变 prop。如果你这样做了，vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过$emit 派发一个自定义事件，父组件接收到后，由父组件修改。

#### **42. 在哪个生命周期内调用异步请求**

可以在钩子函数 **created、beforeMount、mounted** 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端返回的数据进行赋值。

但是推荐在 created 钩子函数中调用异步请求，优点如下：

- 能更快获取到服务端数据，减少页面 loading 时间
- ssr 不支持 beforeMount、mounted 钩子函数，所以放在 created 中有助于一致性。

#### **43. 在什么阶段才能访问操作 DOM**

生命周期钩子顺序：
**beforeCreated => created => beforMounted => mounted**

在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM。

#### **44. 父组件可以监听到子组件的生命周期吗？**

- 可以在子组件的生命周期手动通过 **$emit** 触发发组件的事件。
- 可以在父组件引用子组件时通过 **@hook** 来监听即可
  :::tip

  **_@hook:mounted="handleHookMounted"_**

  当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听

  :::

#### **45. Vuex 是通过什么方式提供响应式数据的？原理是什么？**

Vuex 的两大核心 State 和 Getters 都是响应的，即当 state 或 getters 的某一个状态改变时，它是能驱动视图发生相应的改变。

**整体思路是数据劫持 + 观察者模式**

对象内部通过 `difineReactive` 方法，使用 `Object.defineProperty` 将属性进行劫持（只会劫持已存在的属性），数组则是通过重写数组来实现。当页面使用对应属性时，每个属性都拥有自己的 `dep` 属性，存在它所依赖的`watcher` （收集依赖）get，当属性变化后子集对应的 `watcher` 去更新（派发更新） set。

- `Object.defineProperty` 数据劫持
- 使用`getter`收集依赖，`setter` 通知 `watcher`派发更新
- `watcher` 发布订阅模式

#### **46. diff 算法了解吗？**

diff 算法采用同级比较。

- tag 标签不一致直接新节点替换旧节点。
- tag 标签一样。

  - 先替换属性
  - 对比子元素

    - 新老都有子元素，采用双指针方式进行对比

      sameVnode 判断 tag 和 key 完全相同为同一节点，进行节点复用

      头和头相等对比

      尾和尾相等对比

      头和尾相等对比

      sameVnod 的时候传入两个新老子节点 patch(oldChild,newChild)

      乱序情况 -- 上面的都不符合，先遍历子节点数组形成 key 值映射的 map 对象。

      然后根据新子节点数组循环 按照 key 值和位置关系移动以及新增节点 最后删除多余的旧子节点 如果移动旧子节点同样需要 patch(oldChild,newChild)

    - 新的有子元素，老的没有子元素。-- 直接将子元素虚拟节点处啊还成真实节点插入即可。
    - 新的没有子元素，老的有子元素。 -- 直接清空 innerHtml

  - 无 tag 标签 -- 文本节点直接比较内容是否一致。

#### **47. 函数式组件使用场景和原理**

- 函数式组件与普通组件的区别

  - 函数式组件需要在声明组件时指定 **function:true**
  - 不需要实例化，所以没有 this，this 通过 render 函数的第二个参数 context 代替
  - 没有生命周期钩子函数，不能使用计算属性， watch
  - 不能通过 **$emit** 对外暴露事件，调用事件只能通过 **context.listeners.click** 的方式调用外部传入的事件
  - 因为函数组件时没有实例化，所以在外部通过 ref 去引用组件时，实际用的是 **HTMLElement**
  - 函数式组件的 props 可以不用显示声明，所以没有在 props 里面声明的属性都会被自动隐式解析为 prop，而普通的组件所有为声明的属性都解析道 **$attrs** 里面，并自动挂载到组件根元素上（可以通过 inheritAttrs 属性禁止）

- 优点

  - 由于函数组件不需要实例化，无状态，没有生命周期，所以渲染性要好于普通组件
  - 函数组件结构比较简单，代码结构更清晰

- 使用场景

  - 一个简单的展示组件，作为容器组件使用比如 route-view 就是一个函数式组件。
  - 高阶组件 --> 用于接收一个组件为参数，返回一个被包装过的组件。

#### **48. 生命周期钩子是如何实现的？**

Vue 的生命周期钩子核心实现是利用发布订阅模式先把用户传入的生命周期钩子订阅好（内部采用数组的方法存储）然后在创建组件实例的过程中会一次执行对应的钩子方法（发布）

#### **49. Vue 模板编译原理**

Vue 的编译过程就是将 `template` 转化为 `render` 函数的过程，分为三步：

- 第一步是将模板字符串转换成 `element AST` （解析器）
- 第二步是对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）
- 第三步是使用 `element AST` 生成 `render` 函数代码字符串（代码生成器）

#### **50. 写过自定义指令吗？原理是什么？**

指令本质上是装饰器，是 vue 对 HTML 元素的扩展，给 HTML 元素添加自定义功能。vue 编译 DOM 时，会找到指令对象，执行指令的相关方法。

自定义指令有五个生命周期（也叫钩子函数），分别是 `bind、inserted、update、componentUpdated、unbind`

- `bind`：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
- `inserted`：被绑定元素插入父节点时调用。
- `update`：被绑定元素所造的模板更新时调用，而不被轮绑定值是否变化。通过比较前后的绑定值。
- `componentUpdated`：被绑定元素所在模板完成一次更新周期时调用。
- `unbind`：只调用一次，指令与元素解绑时调用。

**原理：**

- 在生成 `AST` 语法树时，遇到指令会给当前元素添加 `directives`属性。
- 通过 `genDirectives` 生成指令代码。
- 在 `patch` 前将指令的钩子提取到 **_cbs_** 中，在 `patch` 过程中调用对应的钩子。
- 当执行指令对应钩子函数时，调用对应指令定义方法。

#### **51. Vue.extend 作用和原理**

:::tip
**官方解释：** `Vue.extend` 使用基础 Vue 构造器，创建一个子类。参数时一个包含组件选项的对象。
:::

其实就是一个子类构造器，是 Vue 组件的核心 API。实现思路就是使用原型继承的方法返回了 vue 的子类，并且利用 `mergeOptions` 把传入组件的 `options` 就是父类的 `options` 进行了合并。

#### **52. Vue.mixin 的使用场景和原理**

在日常开发中，我们经常会遇到在不同组件中经常用到一些相同或者相似的代码，这些代码的功能相对独立，可以通过 vue 的 mixin 功能抽离公共的业务逻辑，原理类似对象的继承，当组件初始化时会调用 `mergeOptions` 方法进行合并，采用策略模式针对不同的属性进行合并。当组件和混入对象含有相同名选项时，这些选项将以恰当的方式进行合并。

#### **53. Vue 框架怎么实现对象和数组的监听？**

Vue 框架是通过遍历数组和递归遍历对象，从而达到利用 `Object.defineProperty()` 也能对对象和数组（部分方法的操作）进行监听。

#### **54. Proxy 和 Object.defineProperty 优劣对比**

- **Proxy 优势：**

  - 可以直接监听对象而非属性
  - 可以直接监听数组的变化
  - 有多达 13 种拦截方法，不限于 `apply`、`ownKeys`、`deleteProperty` 、`has` 等等是 `Object.defineProperty` 不具备的。
  - 返回的是一个新对象，我们可以只操作新的对象达到目的，而 `Object.defineProperty()`只能遍历对象属性直接修改
  - 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准性能红利

- **Object.defineProperty 优势：**

  - 兼容性好，支持 IE9，而 Proxy 存在浏览器兼容性问题，而且无法用 `polyfill` 磨平，因此 Vue 的作者才声明需要等到下个大版本（3.0）才能用 `Proxy` 重写。

#### **55. 完整的导航解析流程**

- 导航被触发
- 在失活的组件里调用 `beforeRouterLeave` 守卫
- 调用全局的 `beforeEach` 守卫
- 在重用的组件调用 `beforeRouterUpdate` 守卫（2.2+）
- 调用路由配置里面的 `beforeEnter` 守卫
- 解析异步路由组件
- 在被激活的组件里调用 `beforeRouterEnter`
- 调用全局的 `beforeResolve` 守卫（2.5+）
- 导航被确认
- 调用全局的 `afterEach` 钩子
- 触发 DOM 更新
- 调用 `beforeRouterEnter` 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入

#### **56. Vuex 页面刷新数据丢失怎么解决**

需要做 vuex 的数据持久化，一般使用本地储存的方案来保存数据，可以自己设计存储方案，也可以使用第三方插件。

推荐使用 `vuex-persist` 插件，它是为 Vuex 持久化储存而生的一个插件。不需要你手动存取`storage`,而是直接将状态保存至`cookie` 或者 `localStorage` 中。
