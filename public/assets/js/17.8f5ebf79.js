(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{567:function(v,t,_){v.exports=_.p+"assets/img/data.5de7af21.png"},599:function(v,t,_){"use strict";_.r(t);var s=_(12),r=Object(s.a)({},(function(){var v=this,t=v.$createElement,s=v._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h4",{attrs:{id:"vue-优点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-优点"}},[v._v("#")]),v._v(" "),s("strong",[v._v("Vue 优点")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[v._v("轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 kb")]),v._v(" "),s("li",[v._v("简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习")]),v._v(" "),s("li",[v._v("双向数据绑定：保留了 angular 的特点，在数据操作方面更为简单")]),v._v(" "),s("li",[v._v("组件化：保留了 react 的优点，实现了 html 的封装和重用，在构建单页面应用方面有着独特的优势")]),v._v(" "),s("li",[v._v("视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作")]),v._v(" "),s("li",[v._v("虚拟 DOM：dom 操作是非常耗费性能的， 不再使用原生的 dom 操作节点，极大解放 dom 操作，但具体操作的还是 dom 不过是换了另一种方式")]),v._v(" "),s("li",[v._v("运行速度更快:相比较与 react 而言，同样是操作虚拟 dom，就性能而言，vue 存在很大的优势")])])]),v._v(" "),s("h4",{attrs:{id:"vue-响应式实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-响应式实现原理"}},[v._v("#")]),v._v(" "),s("strong",[v._v("Vue 响应式实现原理")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("p",[v._v("接收 "),s("strong",[v._v("data")]),v._v(" 对象并监听 "),s("strong",[v._v("data")]),v._v(" 变化，遍历此对象所有的 "),s("strong",[v._v("property")]),v._v(" ,并使用 "),s("strong",[v._v("Object.defineProperty()")]),v._v(" 把这些 "),s("strong",[v._v("property")]),v._v(" 全部转为 "),s("strong",[v._v("getter/setter")]),v._v(" 在内部 "),s("strong",[v._v("getter/setter")]),v._v(" 让 Vue 能够追踪依赖在 property 被访问和修改时通知变更")])]),v._v(" "),s("li",[s("p",[v._v("每一个 "),s("strong",[v._v("Component")]),v._v(" 实例都对应一个 "),s("strong",[v._v("watcher")]),v._v(" 实例，它会在组件渲染的过程中把“接触”过的数据 "),s("strong",[v._v("property")]),v._v(" 记录为依赖。之后当依赖项的 "),s("strong",[v._v("setter")]),v._v(" 触发时，会通知 "),s("strong",[v._v("watcher")]),v._v("，从而使它关联的组件重新渲染")]),v._v(" "),s("p",[s("img",{attrs:{src:_(567),alt:"自动获取 input 框焦点"}})])])])]),v._v(" "),s("h4",{attrs:{id:"vue-数据双向绑定实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-数据双向绑定实现"}},[v._v("#")]),v._v(" "),s("strong",[v._v("Vue 数据双向绑定实现")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[v._v("Vue")]),v._v(" 双向数据绑定是通过 数据劫持 结合 发布订阅模式的方式来实现的， 也就是说数据和视图同步，数据发生变化，视图跟着变化，视图变化，数据也随之发生改变；")]),v._v(" "),s("li",[v._v("核心：关于 "),s("strong",[v._v("Vue")]),v._v(" 双向数据绑定，其核心是 "),s("strong",[v._v("Object.defineProperty()")]),v._v(" 方法")])])]),v._v(" "),s("h4",{attrs:{id:"vue-的两个核心点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-的两个核心点"}},[v._v("#")]),v._v(" "),s("strong",[v._v("Vue 的两个核心点")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[v._v("数据驱动:")]),v._v(" "),s("strong",[v._v("ViewModel")]),v._v(" 保证数据和视图的一致性")]),v._v(" "),s("li",[s("strong",[v._v("组件系统:")]),v._v(" 应用类 "),s("strong",[v._v("UI")]),v._v(" 可以看作全部是由组件树构成")])])]),v._v(" "),s("h4",{attrs:{id:"vue-常见指令"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-常见指令"}},[v._v("#")]),v._v(" "),s("strong",[v._v("Vue 常见指令")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[v._v("v-show/v-if:")]),v._v(" 控制节点的显示隐藏")]),v._v(" "),s("li",[s("strong",[v._v("v-for:")]),v._v(" 数据遍历")]),v._v(" "),s("li",[s("strong",[v._v("v-model:")]),v._v(" 双向数据绑定")]),v._v(" "),s("li",[s("strong",[v._v("v-on:click/@click:")]),v._v(" 事件绑定 "),s("strong",[v._v("v-on")]),v._v(" 可以一次绑定多个事件")]),v._v(" "),s("li",[s("strong",[v._v("v-bind/:info:")]),v._v(" 数据绑定")]),v._v(" "),s("li",[s("strong",[v._v("v-once:")]),v._v(" 只绑定一次")])])]),v._v(" "),s("h4",{attrs:{id:"vue-数据传递"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-数据传递"}},[v._v("#")]),v._v(" "),s("strong",[v._v("Vue 数据传递")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[v._v("父组件向子组件传递："),s("strong",[v._v("props")])]),v._v(" "),s("li",[v._v("子组件向父组件传递："),s("strong",[v._v("$emit")])])])]),v._v(" "),s("h4",{attrs:{id:"v-show-和-v-if-区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-show-和-v-if-区别"}},[v._v("#")]),v._v(" "),s("strong",[v._v("v-show 和 v-if 区别")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[v._v("共同点：都是控制元素的显示和隐藏")]),v._v(" "),s("li",[v._v("不同点：本质方法不同")]),v._v(" "),s("li",[s("strong",[v._v("v-show")]),v._v(": 通过 "),s("strong",[v._v("CSS")]),v._v(" 中的 "),s("strong",[v._v("display")]),v._v(" 是否为 "),s("strong",[v._v("none")]),v._v("，来控制元素的显示与隐藏，且只会编译一次")]),v._v(" "),s("li",[s("strong",[v._v("v-if")]),v._v(": 动态的向 "),s("strong",[v._v("DOM")]),v._v(" 树添加或删除 "),s("strong",[v._v("DOM")]),v._v(" 元素，如果初始值设置为 "),s("strong",[v._v("false")]),v._v(" ,则不会编译。且不停的销毁和创建 "),s("strong",[v._v("DOM")]),v._v(" 元素，比较消耗性能")]),v._v(" "),s("li",[v._v("如果需要频繁的切换某节点，使用 "),s("strong",[v._v("v-show")]),v._v(" 更优（初始开销大，切换开销小），如果不需要频繁切换某节点，则使用 "),s("strong",[v._v("v-if")]),v._v(" 更优（初始开销小，切换开销大）")])])]),v._v(" "),s("h4",{attrs:{id:"css-只在当前组件生效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#css-只在当前组件生效"}},[v._v("#")]),v._v(" "),s("strong",[v._v("CSS 只在当前组件生效")])]),v._v(" "),s("blockquote",[s("p",[v._v("在组件的 "),s("strong",[v._v("style")]),v._v(" 前面添加 "),s("strong",[v._v("scoped")])])]),v._v(" "),s("h4",{attrs:{id:"keep-alive-作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive-作用"}},[v._v("#")]),v._v(" "),s("strong",[v._v("keep-alive 作用")])]),v._v(" "),s("blockquote",[s("p",[s("strong",[v._v("keep-alive")]),v._v(" 是 "),s("strong",[v._v("Vue")]),v._v(" 的内置组件，可以使被包含的组件保留状态，避免被重新渲染")])]),v._v(" "),s("h4",{attrs:{id:"如何获取-dom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何获取-dom"}},[v._v("#")]),v._v(" "),s("strong",[v._v("如何获取 DOM")])]),v._v(" "),s("blockquote",[s("p",[v._v("给节点添加 "),s("strong",[v._v("ref=domName")]),v._v(" 属性，通过 "),s("strong",[v._v("this.$refs.domName")]),v._v(" 获取")])]),v._v(" "),s("h4",{attrs:{id:"key-的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#key-的作用"}},[v._v("#")]),v._v(" "),s("strong",[v._v("Key 的作用")])]),v._v(" "),s("blockquote",[s("p",[v._v("每个节点的唯一标识，"),s("strong",[v._v("Diff")]),v._v(" 算法就可以正确识别此节点，高效的更新虚拟 "),s("strong",[v._v("DOM")])])]),v._v(" "),s("h4",{attrs:{id:"v-model-的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-model-的使用"}},[v._v("#")]),v._v(" "),s("strong",[v._v("v-model 的使用")])]),v._v(" "),s("blockquote",[s("p",[v._v("用于表单数据的双向绑定，其实就是一个语法糖，实际上就是 "),s("strong",[v._v("v-bind")]),v._v(" 指令绑定一个 "),s("strong",[v._v("value")]),v._v(" 属性，"),s("strong",[v._v("v-on")]),v._v(" 指令给当前元素绑定 "),s("strong",[v._v("input")]),v._v(" 事件")])]),v._v(" "),s("h4",{attrs:{id:"computed-和-watch-使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#computed-和-watch-使用场景"}},[v._v("#")]),v._v(" "),s("strong",[v._v("computed 和 watch 使用场景")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[v._v("computed:")]),v._v(" 当一个属性受多个属性影响的时候 🌰："),s("strong",[v._v("购物车商品结算的时候")])]),v._v(" "),s("li",[s("strong",[v._v("watch:")]),v._v(" 当一个属性影响多个属性的时候 🌰："),s("strong",[v._v("搜索数据")])])])]),v._v(" "),s("h4",{attrs:{id:"nexttick-的使用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#nexttick-的使用"}},[v._v("#")]),v._v(" "),s("strong",[v._v("$nextTick 的使用")])]),v._v(" "),s("blockquote",[s("p",[v._v("当你修改了 "),s("strong",[v._v("data")]),v._v(" 的值然后马上获取这个 "),s("strong",[v._v("DOM")]),v._v(" 元素的值，是不能获取到更新后的值，你需要使用 "),s("strong",[v._v("$nextTick")]),v._v(" 这个回调，让修改后的 "),s("strong",[v._v("data")]),v._v(" 值渲染更新到 "),s("strong",[v._v("DOM")]),v._v(" 元素之后在获取，才能成功")])]),v._v(" "),s("h4",{attrs:{id:"data-为什么必须是一个函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-为什么必须是一个函数"}},[v._v("#")]),v._v(" "),s("strong",[v._v("data 为什么必须是一个函数")])]),v._v(" "),s("blockquote",[s("p",[v._v("因为 "),s("strong",[v._v("JavaScript")]),v._v(" 的特性所导致，在 "),s("strong",[v._v("Component")]),v._v(" 中，"),s("strong",[v._v("data")]),v._v(" 必须以函数的形式存在，不可以是对象。 组件中的 "),s("strong",[v._v("data")]),v._v("写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的 "),s("strong",[v._v("data")]),v._v(" ，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。而单纯的写成对象形式，就是所有的组件实例共用了一个 "),s("strong",[v._v("data")]),v._v(" ，这样改一个全都改了。")])]),v._v(" "),s("h4",{attrs:{id:"v-if-和-v-for-的优先级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-for-的优先级"}},[v._v("#")]),v._v(" "),s("strong",[v._v("v-if 和 v-for 的优先级")])]),v._v(" "),s("blockquote",[s("p",[v._v("当 "),s("strong",[v._v("v-if")]),v._v(" 与 "),s("strong",[v._v("v-for")]),v._v(" 一起使用时，"),s("strong",[v._v("v-for")]),v._v(" 具有比 "),s("strong",[v._v("v-if")]),v._v(" 更高的优先级，这意味着 "),s("strong",[v._v("v-if")]),v._v(" 将分别重复运行于每个 "),s("strong",[v._v("v-for")]),v._v(" 循环中。所以，不推荐 "),s("strong",[v._v("v-if")]),v._v(" 和 "),s("strong",[v._v("v-for")]),v._v(" 同时使用。 如果 "),s("strong",[v._v("v-if")]),v._v(" 和 "),s("strong",[v._v("v-for")]),v._v(" 一起用的话，"),s("strong",[v._v("Vue")]),v._v(" 中的的会自动提示 "),s("strong",[v._v("v-i")]),v._v("f 应该放到外层去\nVue 3.0 对 "),s("strong",[v._v("v-if")]),v._v(" 和 "),s("strong",[v._v("v-for")]),v._v(" 做了权重比较，可以混合使用")])]),v._v(" "),s("h4",{attrs:{id:"vue-常用的修饰符"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-常用的修饰符"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vue 常用的修饰符")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[v._v(".stop :")]),v._v(" 等同于 "),s("strong",[v._v("JavaScript")]),v._v(" 中的 "),s("strong",[v._v("event.stopPropagation()")]),v._v(" ,防止事件冒泡")]),v._v(" "),s("li",[s("strong",[v._v(".prevent :")]),v._v(" 等同于 "),s("strong",[v._v("JavaScript")]),v._v(" 中的 "),s("strong",[v._v("event.preventDefault()")]),v._v(" ,防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）")]),v._v(" "),s("li",[s("strong",[v._v(".capture :")]),v._v(" 冒泡事件的方向相反，事件捕获由外到内")]),v._v(" "),s("li",[s("strong",[v._v(".self :")]),v._v(" 只触发自己范围内的事件，不包含子元素")]),v._v(" "),s("li",[s("strong",[v._v(".once :")]),v._v(" 只会触发一次")]),v._v(" "),s("li",[s("strong",[v._v(".keyup :")]),v._v(" 按键修饰符")]),v._v(" "),s("li",[s("strong",[v._v(".passive :")]),v._v(" 滚动事件的默认行为 (即滚动行为) 将会立即触发(提升移动端性能)")])])]),v._v(" "),s("h4",{attrs:{id:"vue-router-跳转和-location-href-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-跳转和-location-href-的区别"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vue-router 跳转和 location.href 的区别")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[v._v("location.href")]),v._v(" 跳转简单方便，但是刷新了页面")]),v._v(" "),s("li",[s("strong",[v._v("history.pushState(’/url’)")]),v._v(" 无刷新页面，静态跳转")]),v._v(" "),s("li",[s("strong",[v._v("router.push('/url')")]),v._v(" 使用 "),s("strong",[v._v("diff")]),v._v(" 算法，实现按需加载，减少 "),s("strong",[v._v("DOM")]),v._v(" 消耗")]),v._v(" "),s("li",[v._v("在 "),s("strong",[v._v("history")]),v._v(" 下，"),s("strong",[v._v("history.pushState(’/url’)")]),v._v(" 和 "),s("strong",[v._v("router.push('/url')")]),v._v(" 是一样的，因为 "),s("strong",[v._v("vue-router")]),v._v(" 就是用了"),s("strong",[v._v("history.pushState()")])])])]),v._v(" "),s("h4",{attrs:{id:"vue-router-如何定义动态路由-怎么获取参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-如何定义动态路由-怎么获取参数"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vue-router 如何定义动态路由，怎么获取参数")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[v._v("在 "),s("strong",[v._v("router")]),v._v(" 目录下的 "),s("strong",[v._v("index.js")]),v._v(" 文件中，对 "),s("strong",[v._v("path")]),v._v(" 属性加上 "),s("strong",[v._v("/:id")])]),v._v(" "),s("li",[v._v("使用 "),s("strong",[v._v("router")]),v._v(" 对象的 "),s("strong",[v._v("params.id")])])])]),v._v(" "),s("h4",{attrs:{id:"assets-和-static-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#assets-和-static-的区别"}},[v._v("#")]),v._v(" "),s("strong",[v._v("assets 和 static 的区别")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[v._v("两者都是存放静态资源文件\n"),s("ul",[s("li",[v._v("图片")]),v._v(" "),s("li",[v._v("字体图标")]),v._v(" "),s("li",[v._v("样式文件")])])]),v._v(" "),s("li",[s("strong",[v._v("assets:")]),v._v(" 存放的静态资源在进行 "),s("strong",[v._v("npm run build")]),v._v(" 打包时会将 "),s("strong",[v._v("assets")]),v._v(" 中存放的文件进行打包压缩，代码格式化，并且压缩后的文件都会放在 "),s("strong",[v._v("static")]),v._v(" 文件中跟随 "),s("strong",[v._v("index.html")]),v._v(" 上传至服务器")]),v._v(" "),s("li",[s("strong",[v._v("static:")]),v._v(" 存放的静态资源不会走打包压缩格式化流程，而是直接上传至服务器,对比 "),s("strong",[v._v("assets")]),v._v(" 文件，提价较大，上传至服务器会占据更大的空间")]),v._v(" "),s("li",[s("strong",[v._v("建议：")]),v._v(" 项目中 "),s("strong",[v._v("template")]),v._v(" 的 "),s("strong",[v._v("css、js")]),v._v(" 文件最好都放到 "),s("strong",[v._v("assets")]),v._v(" 中，进行压缩和格式化，减少体积。而对于第三方的资源文件或者 "),s("strong",[v._v("iconfont")]),v._v(" 这些都是经过压缩处理过的，可以直接放在 "),s("strong",[v._v("static")]),v._v(" 中")])])]),v._v(" "),s("h4",{attrs:{id:"slot-的作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#slot-的作用"}},[v._v("#")]),v._v(" "),s("strong",[v._v("slot 的作用")])]),v._v(" "),s("blockquote",[s("p",[s("strong",[v._v("slot")]),v._v(" 插槽，它的作用即父组件内放了一些 "),s("strong",[v._v("DOM")]),v._v(" , 这些 "),s("strong",[v._v("DOM")]),v._v(" 是显示还是不显示，在哪里显示，如何显示，这就是 "),s("strong",[v._v("slot")]),v._v(" 的分发作用")])]),v._v(" "),s("h4",{attrs:{id:"router-link-在电脑上有用-在安卓上没反应"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#router-link-在电脑上有用-在安卓上没反应"}},[v._v("#")]),v._v(" "),s("strong",[v._v("router-link 在电脑上有用，在安卓上没反应")])]),v._v(" "),s("blockquote",[s("p",[s("strong",[v._v("Vue")]),v._v(" 路由在 "),s("strong",[v._v("Android")]),v._v(" 机上有问题，"),s("strong",[v._v("babel")]),v._v(" 问题，安装 "),s("strong",[v._v("babel polypill")]),v._v(" 插件解决")])]),v._v(" "),s("h4",{attrs:{id:"vue2-中注册在-router-link-上事件无效"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue2-中注册在-router-link-上事件无效"}},[v._v("#")]),v._v(" "),s("strong",[v._v("Vue2 中注册在 router-link 上事件无效")])]),v._v(" "),s("blockquote",[s("p",[v._v("使用 "),s("strong",[v._v("@click.native")]),v._v(" 原因："),s("strong",[v._v("router-link")]),v._v(" 会阻止 "),s("strong",[v._v("click")]),v._v(" 事件，"),s("strong",[v._v(".native")]),v._v(" 指直接监听一个原生事件")])]),v._v(" "),s("h4",{attrs:{id:"vue-loader-作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-loader-作用"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vue-loader 作用")])]),v._v(" "),s("blockquote",[s("p",[v._v("它是 "),s("strong",[v._v("webpack")]),v._v(" 的一个 "),s("strong",[v._v("loader")]),v._v(" ，用于处理 "),s("strong",[v._v(".vue")]),v._v(" 文件，将 "),s("strong",[v._v("template/style/js")]),v._v(" 转换成 js 模块")]),v._v(" "),s("ul",[s("li",[v._v("js => es6/7/8/9")]),v._v(" "),s("li",[v._v("style => sass/scss/less")]),v._v(" "),s("li",[v._v("template => html")])])]),v._v(" "),s("h4",{attrs:{id:"vue-项目是打包了一个-js-文件-一个-css-文件-还是有多个文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-项目是打包了一个-js-文件-一个-css-文件-还是有多个文件"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vue 项目是打包了一个 js 文件，一个 css 文件，还是有多个文件")])]),v._v(" "),s("blockquote",[s("p",[v._v("根据 "),s("strong",[v._v("vue-cli")]),v._v(" 脚手架规范，一个 "),s("strong",[v._v("js")]),v._v(" 文件，一个 "),s("strong",[v._v("CSS")]),v._v(" 文件")])]),v._v(" "),s("h4",{attrs:{id:"vuex-有哪几种属性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-有哪几种属性"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vuex 有哪几种属性")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[v._v("state")]),v._v(" "),s("li",[v._v("getter")]),v._v(" "),s("li",[v._v("mutation")]),v._v(" "),s("li",[v._v("action")]),v._v(" "),s("li",[v._v("module")])])]),v._v(" "),s("h4",{attrs:{id:"vuex-中的-store-特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-中的-store-特性"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vuex 中的 store 特性")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[v._v("vuex")]),v._v(" 就像是一个仓库，仓库里面放了很多对象。其中 "),s("strong",[v._v("state")]),v._v(" 就是数据源存放地，对应 "),s("strong",[v._v("vue")]),v._v(" 里面的 "),s("strong",[v._v("data")])]),v._v(" "),s("li",[s("strong",[v._v("state")]),v._v(" 里面存放的数据源是响应式的，"),s("strong",[v._v("vue")]),v._v(" 组件从 "),s("strong",[v._v("store")]),v._v(" 读取数据，若是 "),s("strong",[v._v("store")]),v._v(" 中的数据发生变化，依赖这组数据的组件也会发生更新")]),v._v(" "),s("li",[v._v("它通过 "),s("strong",[v._v("mapState")]),v._v(" 把全局的 "),s("strong",[v._v("state")]),v._v(" 和 "),s("strong",[v._v("getter")]),v._v(" 映射到当前组件的 "),s("strong",[v._v("computed")]),v._v(" 中")])])]),v._v(" "),s("h4",{attrs:{id:"vuex-中的-getter-的特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-中的-getter-的特性"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vuex 中的 getter 的特性")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[v._v("getter")]),v._v(" 可以对 "),s("strong",[v._v("state")]),v._v(" 进行计算操作，它就是 "),s("strong",[v._v("store")]),v._v(" 的计算属性")]),v._v(" "),s("li",[v._v("虽然在组件内也可以做计算属性，但是 "),s("strong",[v._v("getters")]),v._v(" 可以在多个组件内复用")]),v._v(" "),s("li",[v._v("如果一个状态只在一个组件内使用，是可以不用 "),s("strong",[v._v("getters")])])])]),v._v(" "),s("h4",{attrs:{id:"vuex-中的-mutation-的特性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vuex-中的-mutation-的特性"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vuex 中的 mutation 的特性")])]),v._v(" "),s("blockquote",[s("p",[s("strong",[v._v("action")]),v._v(" 类似于 "),s("strong",[v._v("mutation")]),v._v(" ,但是 "),s("strong",[v._v("action")]),v._v(" 提交的是 "),s("strong",[v._v("mutation")]),v._v(" , 而不是直接变更状态， "),s("strong",[v._v("action")]),v._v(" 可以包含任意异步操作")])]),v._v(" "),s("h4",{attrs:{id:"vue-中的-ajax-请求是应该写在组件还是-action-中"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-中的-ajax-请求是应该写在组件还是-action-中"}},[v._v("#")]),v._v(" "),s("strong",[v._v("vue 中的 ajax 请求是应该写在组件还是 action 中")])]),v._v(" "),s("blockquote",[s("p",[v._v("如果请求的数据不被其他组件公用，仅仅在组件内部使用，既不需要放在 "),s("strong",[v._v("vuex")]),v._v(" 的 "),s("strong",[v._v("state")]),v._v(" 中。 如果请求的请求的数据被多个组件公用的话，请将请求放在 "),s("strong",[v._v("action")]),v._v(" 中，方便数据复用，并包裹成 "),s("strong",[v._v("Promise")]),v._v(" 返回")])]),v._v(" "),s("h4",{attrs:{id:"为什么要使用-vuex"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么要使用-vuex"}},[v._v("#")]),v._v(" "),s("strong",[v._v("为什么要使用 vuex")])]),v._v(" "),s("blockquote",[s("ul",[s("li",[v._v("提高代码的可维护性，方便修改数据，使用 "),s("strong",[v._v("vuex")]),v._v(" 修改数据时只用修改一处，反之你需要修改三处")]),v._v(" "),s("li",[v._v("提升代码的可读性，因为一个组件里面的数据你看不出是从哪里来的")]),v._v(" "),s("li",[v._v("降低耦合度，本来 "),s("strong",[v._v("Vue")]),v._v(" 的 "),s("strong",[v._v("Component")]),v._v(" 就是为了减少耦合，如果不用 "),s("strong",[v._v("Vuex")]),v._v(" 会大量的上传派发，会让耦合度大大增加")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);