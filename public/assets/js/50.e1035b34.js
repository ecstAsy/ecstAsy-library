(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{640:function(v,e,_){"use strict";_.r(e);var o=_(12),l=Object(o.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h4",{attrs:{id:"mvvm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mvvm"}},[v._v("#")]),v._v(" "),_("strong",[v._v("MVVM")])]),v._v(" "),_("p",[v._v("MVVM 即 "),_("code",[v._v("Model-View-ViewModel")]),v._v(" 的简写。即"),_("code",[v._v("模型-视图-视图模型")]),v._v("。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("Model（模型）:")]),v._v(" 指的是后端传递的数据。")]),v._v(" "),_("li",[_("strong",[v._v("View （视图）:")]),v._v(" 指的是所看到的页面。")]),v._v(" "),_("li",[_("strong",[v._v("ViewModel（视图模型）:")]),v._v(" 是 "),_("code",[v._v("mvvm")]),v._v(" 模式的核心，它是连接 "),_("code",[v._v("view")]),v._v(" 和 "),_("code",[v._v("model")]),v._v(" 的桥梁。")])]),v._v(" "),_("p",[v._v("它有两个方向：")]),v._v(" "),_("ul",[_("li",[v._v("将"),_("code",[v._v("模型（Model）")]),v._v("转化成"),_("code",[v._v("视图(View)")]),v._v("，即将后端传递的数据转化成所看到的页面。实现的方式是："),_("strong",[_("em",[v._v("数据绑定")])]),v._v("。")]),v._v(" "),_("li",[v._v("将"),_("code",[v._v("视图（View）")]),v._v("转化成"),_("code",[v._v("模型（Model）")]),v._v("，即将所看到的页面转化成后端的数据。实现的方式是："),_("strong",[_("em",[v._v("DOM 事件监听")])]),v._v("。")])]),v._v(" "),_("p",[_("strong",[v._v("这两个方向都实现的，我们称之为数据的双向绑定。")])]),v._v(" "),_("h4",{attrs:{id:"mvc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mvc"}},[v._v("#")]),v._v(" "),_("strong",[v._v("MVC")])]),v._v(" "),_("p",[v._v("MVC 是 "),_("code",[v._v("Model-View-Controller")]),v._v(" 的简写,即"),_("code",[v._v("模型-视图-控制器")]),v._v("。")]),v._v(" "),_("p",[v._v("M 和 V 指的意思和 MVVM 中的 M 和 V 意思一样。\nC 即 "),_("strong",[v._v("Controller")]),v._v(" 指的是页面业务逻辑。使用 MVC 的目的就是将 M 和 V 的代码分离。MVC 是单向通信。也就是 View 跟 Model，必须通过 Controller 来承上启下。")]),v._v(" "),_("p",[v._v("MVC 和 MVVM 的区别并不是 VM 完全取代了 C，只是在 MVC 的基础上增加了一层 VM，只不过是弱化了 C 的概念，ViewModel 存在目的在于抽离 Controller 中展示的业务逻辑，而不是替代 Controller，其它视图操作业务等还是应该放在 Controller 中实现。也就是说 MVVM 实现的是业务逻辑组件的重用，使开发更高效，结构更清晰，增加代码的复用性。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("MVC 框架\nMVC 全名是 Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC 被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。")])]),v._v(" "),_("li",[_("p",[v._v("MVC 编程模式\nMVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式： [1]")])])]),v._v(" "),_("p",[v._v("Model（模型）表示应用程序核心（如数据库）。")]),v._v(" "),_("p",[v._v("View（视图）显示效果（HTML 页面）。")]),v._v(" "),_("p",[v._v("Controller（控制器）处理输入（业务逻辑）。")]),v._v(" "),_("p",[v._v("MVC 模式同时提供了对 HTML、CSS 和 JavaScript 的完全控制。")]),v._v(" "),_("p",[v._v("Model（模型）是应用程序中用于处理应用程序数据逻辑的部分。\n　　通常模型对象负责在数据库中存取数据。")]),v._v(" "),_("p",[v._v("View（视图）是应用程序中处理数据显示的部分。\n　　通常视图是依据模型数据创建的。")]),v._v(" "),_("p",[v._v("Controller（控制器）是应用程序中处理用户交互的部分。\n　　通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("MVVM 框架\nMVVM 是 Model-View-ViewModel 的简写。它本质上就是 MVC 的改进版。MVVM 就是将其中的 View 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。当然这些事 ViewModel 已经帮我们做了，它可以取出 Model 的数据同时帮忙处理 View 中由于需要展示内容而涉及的业务逻辑。微软的 WPF 带来了新的技术体验，如 Silverlight、音频、视频、3D、动画……，这导致了软件 UI 层更加细节化、可定制化。同时，在技术层面，WPF 也带来了 诸如 Binding、Dependency Property、Routed Events、Command、DataTemplate、ControlTemplate 等新特性。MVVM（Model-View-ViewModel）框架的由来便是 MVP（Model-View-Presenter）模式与 WPF 结合的应用方式时发展演变过来的一种新型架构框架。它立足于原有 MVP 框架并且把 WPF 的新特性糅合进去，以应对客户日益复杂的需求变化。")])]),v._v(" "),_("li",[_("p",[v._v("MVVM 模式的组成部分\n模型\n模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("视图\n就像在 MVC 和 MVP 模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。")])]),v._v(" "),_("li",[_("p",[v._v("视图模型\n视图模型是暴露公共属性和命令的视图的抽象。MVVM 没有 MVC 模式的控制器，也没有 MVP 模式的 presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。")])]),v._v(" "),_("li",[_("p",[v._v("绑定器\n声明性数据和命令绑定隐含在 MVVM 模式中。在 Microsoft 解决方案堆中，绑定器是一种名为 XAML 的标记语言。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。")])])])])]),v._v(" "),_("p",[_("strong",[v._v("MVVM 框架与 MVC 框架的区别")]),v._v("\nmvc 和 mvvm 其实区别并不大。都是一种设计思想，主要区别如下：")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("mvc 中 Controller 演变成 mvvm 中的 viewModel")])]),v._v(" "),_("li",[_("p",[v._v("mvvm 通过数据来驱动视图层的显示而不是节点操作。")])]),v._v(" "),_("li",[_("p",[v._v("mvc 中 Model 和 View 是可以直接打交道的，造成 Model 层和 View 层之间的耦合度高。而 mvvm 中 Model 和 View 不直接交互，而是通过中间桥梁 ViewModel 来同步")])]),v._v(" "),_("li",[_("p",[v._v("mvvm 主要解决了:mvc 中大量的 DOM 操作使页面渲染性能降低，加载速度变慢，影响用户体验")])])])])}),[],!1,null,null,null);e.default=l.exports}}]);